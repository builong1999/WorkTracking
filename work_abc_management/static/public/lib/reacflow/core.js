/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@reactflow/core@11.7.4/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { jsx as e, jsxs as t, Fragment as n } from "/npm/react@18.2.0/jsx-runtime/+esm"; import { createContext as o, memo as r, useMemo as a, forwardRef as i, useEffect as s, useRef as d, useContext as l, useState as c, useCallback as u } from "/npm/react@18.2.0/+esm"; import g from "/npm/classcat@5.0.4/+esm"; import { useStore as h, createStore as p } from "/npm/zustand@4.4.6/+esm"; import { shallow as m } from "/npm/zustand@4.4.6/shallow/+esm"; import { drag as y } from "/npm/d3-drag@3.0.0/+esm"; import { select as f, pointer as S } from "/npm/d3-selection@3.0.0/+esm"; import { zoomIdentity as b, zoom as x } from "/npm/d3-zoom@3.0.0/+esm"; import { createPortal as v } from "/npm/react-dom@18.2.0/+esm"; const E = o(null), C = E.Provider, N = { error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001", error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.", error003: e => `Node type "${e}" not found. Using fallback type "default".`, error004: () => "The React Flow parent container needs a width and a height to render the graph.", error005: () => "Only child nodes can use a parent extent.", error006: () => "Can't create edge. An edge needs a source and a target.", error007: e => `The old edge with id=${e} does not exist.`, error009: e => `Marker type "${e}" doesn't exist.`, error008: (e, t) => `Couldn't create edge for ${e ? "target" : "source"} handle id: "${e ? t.targetHandle : t.sourceHandle}", edge id: ${t.id}.`, error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.", error011: e => `Edge type "${e}" not found. Using fallback type "default".` }, w = N.error001(); function M(e, t) { const n = l(E); if (null === n) throw new Error(w); return h(n, e, t) } const P = () => { const e = l(E); if (null === e) throw new Error(w); return a((() => ({ getState: e.getState, setState: e.setState, subscribe: e.subscribe, destroy: e.destroy })), [e]) }, O = e => e.userSelectionActive ? "none" : "all"; function I({ position: t, children: n, className: o, style: r, ...a }) { const i = M(O), s = `${t}`.split("-"); return e("div", { className: g(["react-flow__panel", o, ...s]), style: { ...r, pointerEvents: i }, ...a, children: n }) } function k({ proOptions: t, position: n = "bottom-right" }) { return t?.hideAttribution ? null : e(I, { position: n, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: e("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) }) } var D = r((({ x: n, y: o, label: r, labelStyle: a = {}, labelShowBg: i = !0, labelBgStyle: l = {}, labelBgPadding: u = [2, 4], labelBgBorderRadius: h = 2, children: p, className: m, ...y }) => { const f = d(null), [S, b] = c({ x: 0, y: 0, width: 0, height: 0 }), x = g(["react-flow__edge-textwrapper", m]); return s((() => { if (f.current) { const e = f.current.getBBox(); b({ x: e.x, y: e.y, width: e.width, height: e.height }) } }), [r]), void 0 !== r && r ? t("g", { transform: `translate(${n - S.width / 2} ${o - S.height / 2})`, className: x, visibility: S.width ? "visible" : "hidden", ...y, children: [i && e("rect", { width: S.width + 2 * u[0], x: -u[0], y: -u[1], height: S.height + 2 * u[1], className: "react-flow__edge-textbg", style: l, rx: h, ry: h }), e("text", { className: "react-flow__edge-text", y: S.height / 2, dy: "0.3em", ref: f, style: a, children: r }), p] }) : null })); const A = e => ({ width: e.offsetWidth, height: e.offsetHeight }), B = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), $ = (e = { x: 0, y: 0 }, t) => ({ x: B(e.x, t[0][0], t[1][0]), y: B(e.y, t[0][1], t[1][1]) }), z = (e, t, n) => e < t ? B(Math.abs(e - t), 1, 50) / 50 : e > n ? -B(Math.abs(e - n), 1, 50) / 50 : 0, _ = (e, t) => [20 * z(e.x, 35, t.width - 35), 20 * z(e.y, 35, t.height - 35)], L = e => e.getRootNode?.() || window?.document, R = (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), x2: Math.max(e.x2, t.x2), y2: Math.max(e.y2, t.y2) }), H = ({ x: e, y: t, width: n, height: o }) => ({ x: e, y: t, x2: e + n, y2: t + o }), T = ({ x: e, y: t, x2: n, y2: o }) => ({ x: e, y: t, width: n - e, height: o - t }), Y = e => ({ ...e.positionAbsolute || { x: 0, y: 0 }, width: e.width || 0, height: e.height || 0 }), X = (e, t) => T(R(H(e), H(t))), V = (e, t) => { const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y)); return Math.ceil(n * o) }, Z = e => K(e.width) && K(e.height) && K(e.x) && K(e.y), K = e => !isNaN(e) && isFinite(e), U = Symbol.for("internals"), F = ["Enter", " ", "Escape"]; function W(e) { const t = (e => "nativeEvent" in e)(e) ? e.nativeEvent : e, n = t.composedPath?.()?.[0] || e.target; return ["INPUT", "SELECT", "TEXTAREA"].includes(n?.nodeName) || n?.hasAttribute("contenteditable") || !!n?.closest(".nokey") } const G = e => "clientX" in e, j = (e, t) => { const n = G(e), o = n ? e.clientX : e.touches?.[0].clientX, r = n ? e.clientY : e.touches?.[0].clientY; return { x: o - (t?.left ?? 0), y: r - (t?.top ?? 0) } }, q = ({ id: o, path: r, labelX: a, labelY: i, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g, style: h, markerEnd: p, markerStart: m, interactionWidth: y = 20 }) => t(n, { children: [e("path", { id: o, style: h, d: r, fill: "none", className: "react-flow__edge-path", markerEnd: p, markerStart: m }), y && e("path", { d: r, fill: "none", strokeOpacity: 0, strokeWidth: y, className: "react-flow__edge-interaction" }), s && K(a) && K(i) ? e(D, { x: a, y: i, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g }) : null] }); q.displayName = "BaseEdge"; const Q = (e, t) => void 0 !== t && t ? `url(#${t})` : void 0 !== e ? `url(#react-flow__${e})` : "none"; function J(e, t, n) { return void 0 === n ? n : o => { const r = t().edges.find((t => t.id === e)); r && n(o, { ...r }) } } function ee({ sourceX: e, sourceY: t, targetX: n, targetY: o }) { const r = Math.abs(n - e) / 2, a = n < e ? n + r : n - r, i = Math.abs(o - t) / 2; return [a, o < t ? o + i : o - i, r, i] } function te({ sourceX: e, sourceY: t, targetX: n, targetY: o, sourceControlX: r, sourceControlY: a, targetControlX: i, targetControlY: s }) { const d = .125 * e + .375 * r + .375 * i + .125 * n, l = .125 * t + .375 * a + .375 * s + .125 * o; return [d, l, Math.abs(d - e), Math.abs(l - t)] } var ne, oe, re, ae, ie, se; function de({ pos: e, x1: t, y1: n, x2: o, y2: r }) { return e === se.Left || e === se.Right ? [.5 * (t + o), n] : [t, .5 * (n + r)] } function le({ sourceX: e, sourceY: t, sourcePosition: n = se.Bottom, targetX: o, targetY: r, targetPosition: a = se.Top }) { const [i, s] = de({ pos: n, x1: e, y1: t, x2: o, y2: r }), [d, l] = de({ pos: a, x1: o, y1: r, x2: e, y2: t }), [c, u, g, h] = te({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: i, sourceControlY: s, targetControlX: d, targetControlY: l }); return [`M${e},${t} C${i},${s} ${d},${l} ${o},${r}`, c, u, g, h] } !function (e) { e.Strict = "strict", e.Loose = "loose" }(ne || (ne = {})), function (e) { e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal" }(oe || (oe = {})), function (e) { e.Partial = "partial", e.Full = "full" }(re || (re = {})), function (e) { e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier" }(ae || (ae = {})), function (e) { e.Arrow = "arrow", e.ArrowClosed = "arrowclosed" }(ie || (ie = {})), function (e) { e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom" }(se || (se = {})); const ce = r((({ sourceX: t, sourceY: n, targetX: o, targetY: r, sourcePosition: a = se.Bottom, targetPosition: i = se.Top, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g, style: h, markerEnd: p, markerStart: m, interactionWidth: y }) => { const [f, S, b] = le({ sourceX: t, sourceY: n, sourcePosition: a, targetX: o, targetY: r, targetPosition: i }); return e(q, { path: f, labelX: S, labelY: b, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g, style: h, markerEnd: p, markerStart: m, interactionWidth: y }) })); ce.displayName = "SimpleBezierEdge"; const ue = { [se.Left]: { x: -1, y: 0 }, [se.Right]: { x: 1, y: 0 }, [se.Top]: { x: 0, y: -1 }, [se.Bottom]: { x: 0, y: 1 } }, ge = ({ source: e, sourcePosition: t = se.Bottom, target: n }) => t === se.Left || t === se.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, he = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)); function pe({ sourceX: e, sourceY: t, sourcePosition: n = se.Bottom, targetX: o, targetY: r, targetPosition: a = se.Top, borderRadius: i = 5, centerX: s, centerY: d, offset: l = 20 }) { const [c, u, g, h, p] = function ({ source: e, sourcePosition: t = se.Bottom, target: n, targetPosition: o = se.Top, center: r, offset: a }) { const i = ue[t], s = ue[o], d = { x: e.x + i.x * a, y: e.y + i.y * a }, l = { x: n.x + s.x * a, y: n.y + s.y * a }, c = ge({ source: d, sourcePosition: t, target: l }), u = 0 !== c.x ? "x" : "y", g = c[u]; let h, p, m = []; const [y, f, S, b] = ee({ sourceX: e.x, sourceY: e.y, targetX: n.x, targetY: n.y }); if (i[u] * s[u] == -1) { h = r.x || y, p = r.y || f; const e = [{ x: h, y: d.y }, { x: h, y: l.y }], t = [{ x: d.x, y: p }, { x: l.x, y: p }]; m = i[u] === g ? "x" === u ? e : t : "x" === u ? t : e } else { const e = [{ x: d.x, y: l.y }], n = [{ x: l.x, y: d.y }]; if (m = "x" === u ? i.x === g ? n : e : i.y === g ? e : n, t !== o) { const t = "x" === u ? "y" : "x", o = i[u] === s[t], r = d[t] > l[t], a = d[t] < l[t]; (1 === i[u] && (!o && r || o && a) || 1 !== i[u] && (!o && a || o && r)) && (m = "x" === u ? e : n) } h = m[0].x, p = m[0].y } return [[e, d, ...m, l, n], h, p, S, b] }({ source: { x: e, y: t }, sourcePosition: n, target: { x: o, y: r }, targetPosition: a, center: { x: s, y: d }, offset: l }); return [c.reduce(((e, t, n) => { let o = ""; return o = n > 0 && n < c.length - 1 ? function (e, t, n, o) { const r = Math.min(he(e, t) / 2, he(t, n) / 2, o), { x: a, y: i } = t; if (e.x === a && a === n.x || e.y === i && i === n.y) return `L${a} ${i}`; if (e.y === i) return `L ${a + r * (e.x < n.x ? -1 : 1)},${i}Q ${a},${i} ${a},${i + r * (e.y < n.y ? 1 : -1)}`; const s = e.x < n.x ? 1 : -1; return `L ${a},${i + r * (e.y < n.y ? -1 : 1)}Q ${a},${i} ${a + r * s},${i}` }(c[n - 1], t, c[n + 1], i) : `${0 === n ? "M" : "L"}${t.x} ${t.y}`, e += o }), ""), u, g, h, p] } const me = r((({ sourceX: t, sourceY: n, targetX: o, targetY: r, label: a, labelStyle: i, labelShowBg: s, labelBgStyle: d, labelBgPadding: l, labelBgBorderRadius: c, style: u, sourcePosition: g = se.Bottom, targetPosition: h = se.Top, markerEnd: p, markerStart: m, pathOptions: y, interactionWidth: f }) => { const [S, b, x] = pe({ sourceX: t, sourceY: n, sourcePosition: g, targetX: o, targetY: r, targetPosition: h, borderRadius: y?.borderRadius, offset: y?.offset }); return e(q, { path: S, labelX: b, labelY: x, label: a, labelStyle: i, labelShowBg: s, labelBgStyle: d, labelBgPadding: l, labelBgBorderRadius: c, style: u, markerEnd: p, markerStart: m, interactionWidth: f }) })); me.displayName = "SmoothStepEdge"; const ye = r((t => e(me, { ...t, pathOptions: a((() => ({ borderRadius: 0, offset: t.pathOptions?.offset })), [t.pathOptions?.offset]) }))); function fe({ sourceX: e, sourceY: t, targetX: n, targetY: o }) { const [r, a, i, s] = ee({ sourceX: e, sourceY: t, targetX: n, targetY: o }); return [`M ${e},${t}L ${n},${o}`, r, a, i, s] } ye.displayName = "StepEdge"; const Se = r((({ sourceX: t, sourceY: n, targetX: o, targetY: r, label: a, labelStyle: i, labelShowBg: s, labelBgStyle: d, labelBgPadding: l, labelBgBorderRadius: c, style: u, markerEnd: g, markerStart: h, interactionWidth: p }) => { const [m, y, f] = fe({ sourceX: t, sourceY: n, targetX: o, targetY: r }); return e(q, { path: m, labelX: y, labelY: f, label: a, labelStyle: i, labelShowBg: s, labelBgStyle: d, labelBgPadding: l, labelBgBorderRadius: c, style: u, markerEnd: g, markerStart: h, interactionWidth: p }) })); function be(e, t) { return e >= 0 ? .5 * e : 25 * t * Math.sqrt(-e) } function xe({ pos: e, x1: t, y1: n, x2: o, y2: r, c: a }) { switch (e) { case se.Left: return [t - be(t - o, a), n]; case se.Right: return [t + be(o - t, a), n]; case se.Top: return [t, n - be(n - r, a)]; case se.Bottom: return [t, n + be(r - n, a)] } } function ve({ sourceX: e, sourceY: t, sourcePosition: n = se.Bottom, targetX: o, targetY: r, targetPosition: a = se.Top, curvature: i = .25 }) { const [s, d] = xe({ pos: n, x1: e, y1: t, x2: o, y2: r, c: i }), [l, c] = xe({ pos: a, x1: o, y1: r, x2: e, y2: t, c: i }), [u, g, h, p] = te({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: s, sourceControlY: d, targetControlX: l, targetControlY: c }); return [`M${e},${t} C${s},${d} ${l},${c} ${o},${r}`, u, g, h, p] } Se.displayName = "StraightEdge"; const Ee = r((({ sourceX: t, sourceY: n, targetX: o, targetY: r, sourcePosition: a = se.Bottom, targetPosition: i = se.Top, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g, style: h, markerEnd: p, markerStart: m, pathOptions: y, interactionWidth: f }) => { const [S, b, x] = ve({ sourceX: t, sourceY: n, sourcePosition: a, targetX: o, targetY: r, targetPosition: i, curvature: y?.curvature }); return e(q, { path: S, labelX: b, labelY: x, label: s, labelStyle: d, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: g, style: h, markerEnd: p, markerStart: m, interactionWidth: f }) })); Ee.displayName = "BezierEdge"; const Ce = o(null), Ne = Ce.Provider; Ce.Consumer; const we = () => l(Ce), Me = e => "id" in e && "source" in e && "target" in e, Pe = e => "id" in e && !("source" in e) && !("target" in e), Oe = (e, t, n) => { if (!Pe(e)) return []; const o = n.filter((t => t.source === e.id)).map((e => e.target)); return t.filter((e => o.includes(e.id))) }, Ie = (e, t, n) => { if (!Pe(e)) return []; const o = n.filter((t => t.target === e.id)).map((e => e.source)); return t.filter((e => o.includes(e.id))) }, ke = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `reactflow__edge-${e}${t || ""}-${n}${o || ""}`, De = (e, t) => { if (void 0 === e) return ""; if ("string" == typeof e) return e; return `${t ? `${t}__` : ""}${Object.keys(e).sort().map((t => `${t}=${e[t]}`)).join("&")}` }, Ae = (e, t) => { if (!e.source || !e.target) return t; let n; return n = Me(e) ? { ...e } : { ...e, id: ke(e) }, ((e, t) => t.some((t => !(t.source !== e.source || t.target !== e.target || t.sourceHandle !== e.sourceHandle && (t.sourceHandle || e.sourceHandle) || t.targetHandle !== e.targetHandle && (t.targetHandle || e.targetHandle)))))(n, t) ? t : t.concat(n) }, Be = (e, t, n, o = { shouldReplaceId: !0 }) => { const { id: r, ...a } = e; if (!t.source || !t.target) return n; if (!n.find((e => e.id === r))) return n; const i = { ...a, id: o.shouldReplaceId ? ke(t) : r, source: t.source, target: t.target, sourceHandle: t.sourceHandle, targetHandle: t.targetHandle }; return n.filter((e => e.id !== r)).concat(i) }, $e = ({ x: e, y: t }, [n, o, r], a, [i, s]) => { const d = { x: (e - n) / r, y: (t - o) / r }; return a ? { x: i * Math.round(d.x / i), y: s * Math.round(d.y / s) } : d }, ze = ({ x: e, y: t }, [n, o, r]) => ({ x: e * r + n, y: t * r + o }), _e = (e, t = [0, 0]) => { if (!e) return { x: 0, y: 0, positionAbsolute: { x: 0, y: 0 } }; const n = (e.width ?? 0) * t[0], o = (e.height ?? 0) * t[1], r = { x: e.position.x - n, y: e.position.y - o }; return { ...r, positionAbsolute: e.positionAbsolute ? { x: e.positionAbsolute.x - n, y: e.positionAbsolute.y - o } : r } }, Le = (e, t = [0, 0]) => { if (0 === e.length) return { x: 0, y: 0, width: 0, height: 0 }; const n = e.reduce(((e, n) => { const { x: o, y: r } = _e(n, t).positionAbsolute; return R(e, H({ x: o, y: r, width: n.width || 0, height: n.height || 0 })) }), { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }); return T(n) }, Re = (e, t, [n, o, r] = [0, 0, 1], a = !1, i = !1, s = [0, 0]) => { const d = { x: (t.x - n) / r, y: (t.y - o) / r, width: t.width / r, height: t.height / r }, l = []; return e.forEach((e => { const { width: t, height: n, selectable: o = !0, hidden: r = !1 } = e; if (i && !o || r) return !1; const { positionAbsolute: c } = _e(e, s), u = { x: c.x, y: c.y, width: t || 0, height: n || 0 }, g = V(d, u); (void 0 === t || void 0 === n || null === t || null === n || a && g > 0 || g >= (t || 0) * (n || 0) || e.dragging) && l.push(e) })), l }, He = (e, t) => { const n = e.map((e => e.id)); return t.filter((e => n.includes(e.source) || n.includes(e.target))) }, Te = (e, t, n, o, r, a = .1) => { const i = t / (e.width * (1 + a)), s = n / (e.height * (1 + a)), d = Math.min(i, s), l = B(d, o, r); return [t / 2 - (e.x + e.width / 2) * l, n / 2 - (e.y + e.height / 2) * l, l] }, Ye = (e, t = 0) => e.transition().duration(t); function Xe(e, t, n, o) { return (t[n] || []).reduce(((t, r) => (`${e.id}-${r.id}-${n}` !== o && t.push({ id: r.id || null, type: n, nodeId: e.id, x: (e.positionAbsolute?.x ?? 0) + r.x + r.width / 2, y: (e.positionAbsolute?.y ?? 0) + r.y + r.height / 2 }), t)), []) } const Ve = { source: null, target: null, sourceHandle: null, targetHandle: null }, Ze = () => ({ handleDomNode: null, isValid: !1, connection: Ve, endHandle: null }); function Ke(e, t, n, o, r, a, i) { const s = "target" === r, d = i.querySelector(`.react-flow__handle[data-id="${e?.nodeId}-${e?.id}-${e?.type}"]`), l = { ...Ze(), handleDomNode: d }; if (d) { const e = Ue(void 0, d), r = d.getAttribute("data-nodeid"), i = d.getAttribute("data-handleid"), c = d.classList.contains("connectable"), u = d.classList.contains("connectableend"), g = { source: s ? r : n, sourceHandle: s ? i : o, target: s ? n : r, targetHandle: s ? o : i }; l.connection = g; c && u && (t === ne.Strict ? s && "source" === e || !s && "target" === e : r !== n || i !== o) && (l.endHandle = { nodeId: r, handleId: i, type: e }, l.isValid = a(g)) } return l } function Ue(e, t) { return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null) } function Fe(e) { e?.classList.remove("valid", "connecting", "react-flow__handle-valid", "react-flow__handle-connecting") } function We(e, t) { let n = null; return t ? n = "valid" : e && !t && (n = "invalid"), n } function Ge({ event: e, handleId: t, nodeId: n, onConnect: o, isTarget: r, getState: a, setState: i, isValidConnection: s, edgeUpdaterType: d, onEdgeUpdateEnd: l }) { const c = L(e.target), { connectionMode: u, domNode: g, autoPanOnConnect: h, connectionRadius: p, onConnectStart: m, panBy: y, getNodes: f, cancelConnection: S } = a(); let b, x = 0; const { x: v, y: E } = j(e), C = c?.elementFromPoint(v, E), N = Ue(d, C), w = g?.getBoundingClientRect(); if (!w || !N) return; let M, P = j(e, w), O = !1, I = null, k = !1, D = null; const A = function ({ nodes: e, nodeId: t, handleId: n, handleType: o }) { return e.reduce(((e, r) => { if (r[U]) { const { handleBounds: a } = r[U]; let i = [], s = []; a && (i = Xe(r, a, "source", `${t}-${n}-${o}`), s = Xe(r, a, "target", `${t}-${n}-${o}`)), e.push(...i, ...s) } return e }), []) }({ nodes: f(), nodeId: n, handleId: t, handleType: N }), B = () => { if (!h) return; const [e, t] = _(P, w); y({ x: e, y: t }), x = requestAnimationFrame(B) }; function $(e) { const { transform: o } = a(); P = j(e, w); const { handle: d, validHandleResult: l } = function (e, t, n, o, r, a) { const { x: i, y: s } = j(e), d = t.elementsFromPoint(i, s).find((e => e.classList.contains("react-flow__handle"))); if (d) { const e = d.getAttribute("data-nodeid"); if (e) { const t = Ue(void 0, d), o = d.getAttribute("data-handleid"), r = a({ nodeId: e, id: o, type: t }); if (r) return { handle: { id: o, type: t, nodeId: e, x: n.x, y: n.y }, validHandleResult: r } } } let l = [], c = 1 / 0; if (r.forEach((e => { const t = Math.sqrt((e.x - n.x) ** 2 + (e.y - n.y) ** 2); if (t <= o) { const n = a(e); t <= c && (t < c ? l = [{ handle: e, validHandleResult: n }] : t === c && l.push({ handle: e, validHandleResult: n }), c = t) } })), !l.length) return { handle: null, validHandleResult: Ze() }; if (1 === l.length) return l[0]; const u = l.some((({ validHandleResult: e }) => e.isValid)), g = l.some((({ handle: e }) => "target" === e.type)); return l.find((({ handle: e, validHandleResult: t }) => g ? "target" === e.type : !u || t.isValid)) || l[0] }(e, c, $e(P, o, !1, [1, 1]), p, A, (e => Ke(e, u, n, t, r ? "target" : "source", s, c))); if (b = d, O || (B(), O = !0), D = l.handleDomNode, I = l.connection, k = l.isValid, i({ connectionPosition: b && k ? ze({ x: b.x, y: b.y }, o) : P, connectionStatus: We(!!b, k), connectionEndHandle: l.endHandle }), !b && !k && !D) return Fe(M); I.source !== I.target && D && (Fe(M), M = D, D.classList.add("connecting", "react-flow__handle-connecting"), D.classList.toggle("valid", k), D.classList.toggle("react-flow__handle-valid", k)) } function z(e) { (b || D) && I && k && o?.(I), a().onConnectEnd?.(e), d && l?.(e), Fe(M), S(), cancelAnimationFrame(x), O = !1, k = !1, I = null, D = null, c.removeEventListener("mousemove", $), c.removeEventListener("mouseup", z), c.removeEventListener("touchmove", $), c.removeEventListener("touchend", z) } i({ connectionPosition: P, connectionStatus: null, connectionNodeId: n, connectionHandleId: t, connectionHandleType: N, connectionStartHandle: { nodeId: n, handleId: t, type: N }, connectionEndHandle: null }), m?.(e, { nodeId: n, handleId: t, handleType: N }), c.addEventListener("mousemove", $), c.addEventListener("mouseup", z), c.addEventListener("touchmove", $), c.addEventListener("touchend", z) } const je = () => !0, qe = e => ({ connectionStartHandle: e.connectionStartHandle, connectOnClick: e.connectOnClick, noPanClassName: e.noPanClassName }), Qe = i((({ type: t = "source", position: n = se.Top, isValidConnection: o, isConnectable: r = !0, isConnectableStart: a = !0, isConnectableEnd: i = !0, id: s, onConnect: d, children: l, className: c, onMouseDown: u, onTouchStart: h, ...p }, y) => { const f = s || null, S = "target" === t, b = P(), x = we(), { connectOnClick: v, noPanClassName: E } = M(qe, m), { connecting: C, clickConnecting: w } = M(((e, t, n) => o => { const { connectionStartHandle: r, connectionEndHandle: a, connectionClickStartHandle: i } = o; return { connecting: r?.nodeId === e && r?.handleId === t && r?.type === n || a?.nodeId === e && a?.handleId === t && a?.type === n, clickConnecting: i?.nodeId === e && i?.handleId === t && i?.type === n } })(x, f, t), m); x || b.getState().onError?.("010", N.error010()); const O = e => { const { defaultEdgeOptions: t, onConnect: n, hasDefaultEdges: o } = b.getState(), r = { ...t, ...e }; if (o) { const { edges: e, setEdges: t } = b.getState(); t(Ae(r, e)) } n?.(r), d?.(r) }, I = e => { if (!x) return; const t = G(e); a && (t && 0 === e.button || !t) && Ge({ event: e, handleId: f, nodeId: x, onConnect: O, isTarget: S, getState: b.getState, setState: b.setState, isValidConnection: o || b.getState().isValidConnection || je }), t ? u?.(e) : h?.(e) }; return e("div", { "data-handleid": f, "data-nodeid": x, "data-handlepos": n, "data-id": `${x}-${f}-${t}`, className: g(["react-flow__handle", `react-flow__handle-${n}`, "nodrag", E, c, { source: !S, target: S, connectable: r, connectablestart: a, connectableend: i, connecting: w, connectionindicator: r && (a && !C || i && C) }]), onMouseDown: I, onTouchStart: I, onClick: v ? e => { const { onClickConnectStart: n, onClickConnectEnd: r, connectionClickStartHandle: i, connectionMode: s, isValidConnection: d } = b.getState(); if (!x || !i && !a) return; if (!i) return n?.(e, { nodeId: x, handleId: f, handleType: t }), void b.setState({ connectionClickStartHandle: { nodeId: x, type: t, handleId: f } }); const l = L(e.target), c = o || d || je, { connection: u, isValid: g } = Ke({ nodeId: x, id: f, type: t }, s, i.nodeId, i.handleId || null, i.type, c, l); g && O(u), r?.(e), b.setState({ connectionClickStartHandle: null }) } : void 0, ref: y, ...p, children: l }) })); Qe.displayName = "Handle"; var Je = r(Qe); const et = ({ data: o, isConnectable: r, targetPosition: a = se.Top, sourcePosition: i = se.Bottom }) => t(n, { children: [e(Je, { type: "target", position: a, isConnectable: r }), o?.label, e(Je, { type: "source", position: i, isConnectable: r })] }); et.displayName = "DefaultNode"; var tt = r(et); const nt = ({ data: o, isConnectable: r, sourcePosition: a = se.Bottom }) => t(n, { children: [o?.label, e(Je, { type: "source", position: a, isConnectable: r })] }); nt.displayName = "InputNode"; var ot = r(nt); const rt = ({ data: o, isConnectable: r, targetPosition: a = se.Top }) => t(n, { children: [e(Je, { type: "target", position: a, isConnectable: r }), o?.label] }); rt.displayName = "OutputNode"; var at = r(rt); const it = () => null; it.displayName = "GroupNode"; const st = e => ({ selectedNodes: e.getNodes().filter((e => e.selected)), selectedEdges: e.edges.filter((e => e.selected)) }), dt = e => e.id; function lt(e, t) { return m(e.selectedNodes.map(dt), t.selectedNodes.map(dt)) && m(e.selectedEdges.map(dt), t.selectedEdges.map(dt)) } const ct = r((({ onSelectionChange: e }) => { const t = P(), { selectedNodes: n, selectedEdges: o } = M(st, lt); return s((() => { const r = { nodes: n, edges: o }; e?.(r), t.getState().onSelectionChange?.(r) }), [n, o, e]), null })); ct.displayName = "SelectionListener"; const ut = e => !!e.onSelectionChange; function gt({ onSelectionChange: t }) { const n = M(ut); return t || n ? e(ct, { onSelectionChange: t }) : null } const ht = e => ({ setNodes: e.setNodes, setEdges: e.setEdges, setDefaultNodesAndEdges: e.setDefaultNodesAndEdges, setMinZoom: e.setMinZoom, setMaxZoom: e.setMaxZoom, setTranslateExtent: e.setTranslateExtent, setNodeExtent: e.setNodeExtent, reset: e.reset }); function pt(e, t) { s((() => { void 0 !== e && t(e) }), [e]) } function mt(e, t, n) { s((() => { void 0 !== t && n({ [e]: t }) }), [t]) } const yt = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, onConnect: r, onConnectStart: a, onConnectEnd: i, onClickConnectStart: d, onClickConnectEnd: l, nodesDraggable: c, nodesConnectable: u, nodesFocusable: g, edgesFocusable: h, edgesUpdatable: p, elevateNodesOnSelect: y, minZoom: f, maxZoom: S, nodeExtent: b, onNodesChange: x, onEdgesChange: v, elementsSelectable: E, connectionMode: C, snapGrid: N, snapToGrid: w, translateExtent: O, connectOnClick: I, defaultEdgeOptions: k, fitView: D, fitViewOptions: A, onNodesDelete: B, onEdgesDelete: $, onNodeDrag: z, onNodeDragStart: _, onNodeDragStop: L, onSelectionDrag: R, onSelectionDragStart: H, onSelectionDragStop: T, noPanClassName: Y, nodeOrigin: X, rfId: V, autoPanOnConnect: Z, autoPanOnNodeDrag: K, onError: U, connectionRadius: F, isValidConnection: W }) => { const { setNodes: G, setEdges: j, setDefaultNodesAndEdges: q, setMinZoom: Q, setMaxZoom: J, setTranslateExtent: ee, setNodeExtent: te, reset: ne } = M(ht, m), oe = P(); return s((() => { const e = o?.map((e => ({ ...e, ...k }))); return q(n, e), () => { ne() } }), []), mt("defaultEdgeOptions", k, oe.setState), mt("connectionMode", C, oe.setState), mt("onConnect", r, oe.setState), mt("onConnectStart", a, oe.setState), mt("onConnectEnd", i, oe.setState), mt("onClickConnectStart", d, oe.setState), mt("onClickConnectEnd", l, oe.setState), mt("nodesDraggable", c, oe.setState), mt("nodesConnectable", u, oe.setState), mt("nodesFocusable", g, oe.setState), mt("edgesFocusable", h, oe.setState), mt("edgesUpdatable", p, oe.setState), mt("elementsSelectable", E, oe.setState), mt("elevateNodesOnSelect", y, oe.setState), mt("snapToGrid", w, oe.setState), mt("snapGrid", N, oe.setState), mt("onNodesChange", x, oe.setState), mt("onEdgesChange", v, oe.setState), mt("connectOnClick", I, oe.setState), mt("fitViewOnInit", D, oe.setState), mt("fitViewOnInitOptions", A, oe.setState), mt("onNodesDelete", B, oe.setState), mt("onEdgesDelete", $, oe.setState), mt("onNodeDrag", z, oe.setState), mt("onNodeDragStart", _, oe.setState), mt("onNodeDragStop", L, oe.setState), mt("onSelectionDrag", R, oe.setState), mt("onSelectionDragStart", H, oe.setState), mt("onSelectionDragStop", T, oe.setState), mt("noPanClassName", Y, oe.setState), mt("nodeOrigin", X, oe.setState), mt("rfId", V, oe.setState), mt("autoPanOnConnect", Z, oe.setState), mt("autoPanOnNodeDrag", K, oe.setState), mt("onError", U, oe.setState), mt("connectionRadius", F, oe.setState), mt("isValidConnection", W, oe.setState), pt(e, G), pt(t, j), pt(f, Q), pt(S, J), pt(O, ee), pt(b, te), null }, ft = { display: "none" }, St = { position: "absolute", width: 1, height: 1, margin: -1, border: 0, padding: 0, overflow: "hidden", clip: "rect(0px, 0px, 0px, 0px)", clipPath: "inset(100%)" }, bt = "react-flow__node-desc", xt = "react-flow__edge-desc", vt = "react-flow__aria-live", Et = e => e.ariaLiveMessage; function Ct({ rfId: t }) { const n = M(Et); return e("div", { id: `${vt}-${t}`, "aria-live": "assertive", "aria-atomic": "true", style: St, children: n }) } function Nt({ rfId: o, disableKeyboardA11y: r }) { return t(n, { children: [t("div", { id: `${bt}-${o}`, style: ft, children: ["Press enter or space to select a node.", !r && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), e("div", { id: `${xt}-${o}`, style: ft, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !r && e(Ct, { rfId: o })] }) } const wt = (e, t, n) => n === se.Left ? e - t : n === se.Right ? e + t : e, Mt = (e, t, n) => n === se.Top ? e - t : n === se.Bottom ? e + t : e, Pt = "react-flow__edgeupdater", Ot = ({ position: t, centerX: n, centerY: o, radius: r = 10, onMouseDown: a, onMouseEnter: i, onMouseOut: s, type: d }) => e("circle", { onMouseDown: a, onMouseEnter: i, onMouseOut: s, className: g([Pt, `${Pt}-${d}`]), cx: wt(n, r, t), cy: Mt(o, r, t), r: r, stroke: "transparent", fill: "transparent" }), It = () => !0; var kt = o => { const i = ({ id: r, className: i, type: s, data: l, onClick: u, onEdgeDoubleClick: h, selected: p, animated: m, label: y, labelStyle: f, labelShowBg: S, labelBgStyle: b, labelBgPadding: x, labelBgBorderRadius: v, style: E, source: C, target: N, sourceX: w, sourceY: M, targetX: O, targetY: I, sourcePosition: k, targetPosition: D, elementsSelectable: A, hidden: B, sourceHandleId: $, targetHandleId: z, onContextMenu: _, onMouseEnter: L, onMouseMove: R, onMouseLeave: H, edgeUpdaterRadius: T, onEdgeUpdate: Y, onEdgeUpdateStart: X, onEdgeUpdateEnd: V, markerEnd: Z, markerStart: K, rfId: U, ariaLabel: W, isFocusable: G, isUpdatable: j, pathOptions: q, interactionWidth: Q }) => { const ee = d(null), [te, ne] = c(!1), [oe, re] = c(!1), ae = P(), ie = a((() => `url(#${De(K, U)})`), [K, U]), se = a((() => `url(#${De(Z, U)})`), [Z, U]); if (B) return null; const de = J(r, ae.getState, h), le = J(r, ae.getState, _), ce = J(r, ae.getState, L), ue = J(r, ae.getState, R), ge = J(r, ae.getState, H), he = (e, t) => { if (0 !== e.button) return; const { edges: n, isValidConnection: o } = ae.getState(), a = t ? N : C, i = (t ? z : $) || null, s = t ? "target" : "source", d = o || It, l = t, c = n.find((e => e.id === r)); re(!0), X?.(e, c, s); Ge({ event: e, handleId: i, nodeId: a, onConnect: e => Y?.(c, e), isTarget: l, getState: ae.getState, setState: ae.setState, isValidConnection: d, edgeUpdaterType: s, onEdgeUpdateEnd: e => { re(!1), V?.(e, c, s) } }) }, pe = () => ne(!0), me = () => ne(!1); return t("g", { className: g(["react-flow__edge", `react-flow__edge-${s}`, i, { selected: p, animated: m, inactive: !A && !u, updating: te }]), onClick: e => { const { edges: t, addSelectedEdges: n } = ae.getState(); if (A && (ae.setState({ nodesSelectionActive: !1 }), n([r])), u) { const n = t.find((e => e.id === r)); u(e, n) } }, onDoubleClick: de, onContextMenu: le, onMouseEnter: ce, onMouseMove: ue, onMouseLeave: ge, onKeyDown: G ? e => { if (F.includes(e.key) && A) { const { unselectNodesAndEdges: t, addSelectedEdges: n, edges: o } = ae.getState(); "Escape" === e.key ? (ee.current?.blur(), t({ edges: [o.find((e => e.id === r))] })) : n([r]) } } : void 0, tabIndex: G ? 0 : void 0, role: G ? "button" : void 0, "data-testid": `rf__edge-${r}`, "aria-label": null === W ? void 0 : W || `Edge from ${C} to ${N}`, "aria-describedby": G ? `${xt}-${U}` : void 0, ref: ee, children: [!oe && e(o, { id: r, source: C, target: N, selected: p, animated: m, label: y, labelStyle: f, labelShowBg: S, labelBgStyle: b, labelBgPadding: x, labelBgBorderRadius: v, data: l, style: E, sourceX: w, sourceY: M, targetX: O, targetY: I, sourcePosition: k, targetPosition: D, sourceHandleId: $, targetHandleId: z, markerStart: ie, markerEnd: se, pathOptions: q, interactionWidth: Q }), j && t(n, { children: [("source" === j || !0 === j) && e(Ot, { position: k, centerX: w, centerY: M, radius: T, onMouseDown: e => he(e, !0), onMouseEnter: pe, onMouseOut: me, type: "source" }), ("target" === j || !0 === j) && e(Ot, { position: D, centerX: O, centerY: I, radius: T, onMouseDown: e => he(e, !1), onMouseEnter: pe, onMouseOut: me, type: "target" })] })] }) }; return i.displayName = "EdgeWrapper", r(i) }; function Dt(e) { return { ...{ default: kt(e.default || Ee), straight: kt(e.bezier || Se), step: kt(e.step || ye), smoothstep: kt(e.step || me), simplebezier: kt(e.simplebezier || ce) }, ...Object.keys(e).filter((e => !["default", "bezier"].includes(e))).reduce(((t, n) => (t[n] = kt(e[n] || Ee), t)), {}) } } function At(e, t, n = null) { const o = (n?.x || 0) + t.x, r = (n?.y || 0) + t.y, a = n?.width || t.width, i = n?.height || t.height; switch (e) { case se.Top: return { x: o + a / 2, y: r }; case se.Right: return { x: o + a, y: r + i / 2 }; case se.Bottom: return { x: o + a / 2, y: r + i }; case se.Left: return { x: o, y: r + i / 2 } } } function Bt(e, t) { return e ? 1 !== e.length && t ? t && e.find((e => e.id === t)) || null : e[0] : null } function $t(e) { const t = e?.[U]?.handleBounds || null, n = t && e?.width && e?.height && void 0 !== e?.positionAbsolute?.x && void 0 !== e?.positionAbsolute?.y; return [{ x: e?.positionAbsolute?.x || 0, y: e?.positionAbsolute?.y || 0, width: e?.width || 0, height: e?.height || 0 }, t, !!n] } function zt(e, t) { if (!e.parentNode) return !1; const n = t.get(e.parentNode); return !!n && (!!n.selected || zt(n, t)) } function _t(e, t, n) { let o = e; do { if (o?.matches(t)) return !0; if (o === n.current) return !1; o = o.parentElement } while (o); return !1 } function Lt(e, t, n, o) { return Array.from(e.values()).filter((n => (n.selected || n.id === o) && (!n.parentNode || !zt(n, e)) && (n.draggable || t && void 0 === n.draggable))).map((e => ({ id: e.id, position: e.position || { x: 0, y: 0 }, positionAbsolute: e.positionAbsolute || { x: 0, y: 0 }, distance: { x: n.x - (e.positionAbsolute?.x ?? 0), y: n.y - (e.positionAbsolute?.y ?? 0) }, delta: { x: 0, y: 0 }, extent: e.extent, parentNode: e.parentNode, width: e.width, height: e.height }))) } function Rt(e, t, n, o, r = [0, 0], a) { const i = function (e, t) { return t && "parent" !== t ? [t[0], [t[1][0] - (e.width || 0), t[1][1] - (e.height || 0)]] : t }(e, e.extent || o); let s = i; if ("parent" === e.extent) if (e.parentNode && e.width && e.height) { const t = n.get(e.parentNode), { x: o, y: a } = _e(t, r).positionAbsolute; s = t && K(o) && K(a) && K(t.width) && K(t.height) ? [[o + e.width * r[0], a + e.height * r[1]], [o + t.width - e.width + e.width * r[0], a + t.height - e.height + e.height * r[1]]] : s } else a?.("005", N.error005()), s = i; else if (e.extent && e.parentNode) { const t = n.get(e.parentNode), { x: o, y: a } = _e(t, r).positionAbsolute; s = [[e.extent[0][0] + o, e.extent[0][1] + a], [e.extent[1][0] + o, e.extent[1][1] + a]] } let d = { x: 0, y: 0 }; if (e.parentNode) { const t = n.get(e.parentNode); d = _e(t, r).positionAbsolute } const l = s ? $(t, s) : t; return { position: { x: l.x - d.x, y: l.y - d.y }, positionAbsolute: l } } function Ht({ nodeId: e, dragItems: t, nodeInternals: n }) { const o = t.map((e => ({ ...n.get(e.id), position: e.position, positionAbsolute: e.positionAbsolute }))); return [e ? o.find((t => t.id === e)) : o[0], o] } const Tt = (e, t, n, o) => { const r = t.querySelectorAll(e); if (!r || !r.length) return null; const a = Array.from(r), i = t.getBoundingClientRect(), s = i.width * o[0], d = i.height * o[1]; return a.map((e => { const t = e.getBoundingClientRect(); return { id: e.getAttribute("data-handleid"), position: e.getAttribute("data-handlepos"), x: (t.left - i.left - s) / n, y: (t.top - i.top - d) / n, ...A(e) } })) }; function Yt(e, t, n) { return void 0 === n ? n : o => { const r = t().nodeInternals.get(e); n(o, { ...r }) } } function Xt({ id: e, store: t, unselect: n = !1, nodeRef: o }) { const { addSelectedNodes: r, unselectNodesAndEdges: a, multiSelectionActive: i, nodeInternals: s } = t.getState(), d = s.get(e); t.setState({ nodesSelectionActive: !1 }), d.selected ? (n || d.selected && i) && (a({ nodes: [d] }), requestAnimationFrame((() => o?.current?.blur()))) : r([e]) } function Vt() { const e = P(); return u((({ sourceEvent: t }) => { const { transform: n, snapGrid: o, snapToGrid: r } = e.getState(), a = t.touches ? t.touches[0].clientX : t.clientX, i = t.touches ? t.touches[0].clientY : t.clientY, s = { x: (a - n[0]) / n[2], y: (i - n[1]) / n[2] }; return { xSnapped: r ? o[0] * Math.round(s.x / o[0]) : s.x, ySnapped: r ? o[1] * Math.round(s.y / o[1]) : s.y, ...s } }), []) } function Zt(e) { return (t, n, o) => e?.(t, o) } function Kt({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: o, nodeId: r, isSelectable: a, selectNodesOnDrag: i }) { const l = P(), [u, g] = c(!1), h = d([]), p = d({ x: null, y: null }), m = d(0), S = d(null), b = d({ x: 0, y: 0 }), x = d(null), v = d(!1), E = Vt(); return s((() => { if (e?.current) { const s = f(e.current), d = ({ x: e, y: t }) => { const { nodeInternals: n, onNodeDrag: o, onSelectionDrag: a, updateNodePositions: i, nodeExtent: s, snapGrid: d, snapToGrid: c, nodeOrigin: u, onError: m } = l.getState(); p.current = { x: e, y: t }; let y = !1; if (h.current = h.current.map((o => { const r = { x: e - o.distance.x, y: t - o.distance.y }; c && (r.x = d[0] * Math.round(r.x / d[0]), r.y = d[1] * Math.round(r.y / d[1])); const a = Rt(o, r, n, s, u, m); return y = y || o.position.x !== a.position.x || o.position.y !== a.position.y, o.position = a.position, o.positionAbsolute = a.positionAbsolute, o })), !y) return; i(h.current, !0, !0), g(!0); const f = r ? o : Zt(a); if (f && x.current) { const [e, t] = Ht({ nodeId: r, dragItems: h.current, nodeInternals: n }); f(x.current, e, t) } }, c = () => { if (!S.current) return; const [e, t] = _(b.current, S.current); if (0 !== e || 0 !== t) { const { transform: n, panBy: o } = l.getState(); p.current.x = (p.current.x ?? 0) - e / n[2], p.current.y = (p.current.y ?? 0) - t / n[2], o({ x: e, y: t }) && d(p.current) } m.current = requestAnimationFrame(c) }; if (!t) { const t = y().on("start", (t => { const { nodeInternals: n, multiSelectionActive: o, domNode: s, nodesDraggable: d, unselectNodesAndEdges: c, onNodeDragStart: u, onSelectionDragStart: g } = l.getState(), m = r ? u : Zt(g); i || o || !r || n.get(r)?.selected || c(), r && a && i && Xt({ id: r, store: l, nodeRef: e }); const y = E(t); if (p.current = y, h.current = Lt(n, d, y, r), m && h.current) { const [e, o] = Ht({ nodeId: r, dragItems: h.current, nodeInternals: n }); m(t.sourceEvent, e, o) } S.current = s?.getBoundingClientRect() || null, b.current = j(t.sourceEvent, S.current) })).on("drag", (e => { const t = E(e), { autoPanOnNodeDrag: n } = l.getState(); !v.current && n && (v.current = !0, c()), p.current.x === t.xSnapped && p.current.y === t.ySnapped || !h.current || (x.current = e.sourceEvent, b.current = j(e.sourceEvent, S.current), d(t)) })).on("end", (e => { if (g(!1), v.current = !1, cancelAnimationFrame(m.current), h.current) { const { updateNodePositions: t, nodeInternals: n, onNodeDragStop: o, onSelectionDragStop: a } = l.getState(), i = r ? o : Zt(a); if (t(h.current, !1, !1), i) { const [t, o] = Ht({ nodeId: r, dragItems: h.current, nodeInternals: n }); i(e.sourceEvent, t, o) } } })).filter((t => { const r = t.target; return !t.button && (!n || !_t(r, `.${n}`, e)) && (!o || _t(r, o, e)) })); return s.call(t), () => { s.on(".drag", null) } } s.on(".drag", null) } }), [e, t, n, o, a, l, r, i, E]), u } function Ut() { const e = P(); return u((t => { const { nodeInternals: n, nodeExtent: o, updateNodePositions: r, getNodes: a, snapToGrid: i, snapGrid: s, onError: d, nodesDraggable: l } = e.getState(), c = a().filter((e => e.selected && (e.draggable || l && void 0 === e.draggable))), u = i ? s[0] : 5, g = i ? s[1] : 5, h = t.isShiftPressed ? 4 : 1, p = t.x * u * h, m = t.y * g * h; r(c.map((e => { if (e.positionAbsolute) { const t = { x: e.positionAbsolute.x + p, y: e.positionAbsolute.y + m }; i && (t.x = s[0] * Math.round(t.x / s[0]), t.y = s[1] * Math.round(t.y / s[1])); const { positionAbsolute: r, position: a } = Rt(e, t, n, o, void 0, d); e.position = a, e.positionAbsolute = r } return e })), !0, !1) }), []) } const Ft = { ArrowUp: { x: 0, y: -1 }, ArrowDown: { x: 0, y: 1 }, ArrowLeft: { x: -1, y: 0 }, ArrowRight: { x: 1, y: 0 } }; var Wt = t => { const n = ({ id: n, type: o, data: r, xPos: a, yPos: i, xPosOrigin: l, yPosOrigin: c, selected: u, onClick: h, onMouseEnter: p, onMouseMove: m, onMouseLeave: y, onContextMenu: f, onDoubleClick: S, style: b, className: x, isDraggable: v, isSelectable: E, isConnectable: C, isFocusable: N, selectNodesOnDrag: w, sourcePosition: M, targetPosition: O, hidden: I, resizeObserver: k, dragHandle: D, zIndex: A, isParent: B, noDragClassName: $, noPanClassName: z, initialized: _, disableKeyboardA11y: L, ariaLabel: R, rfId: H }) => { const T = P(), Y = d(null), X = d(M), V = d(O), Z = d(o), K = E || v || h || p || m || y, U = Ut(), G = Yt(n, T.getState, p), j = Yt(n, T.getState, m), q = Yt(n, T.getState, y), Q = Yt(n, T.getState, f), J = Yt(n, T.getState, S); s((() => { if (Y.current && !I) { const e = Y.current; return k?.observe(e), () => k?.unobserve(e) } }), [I]), s((() => { const e = Z.current !== o, t = X.current !== M, r = V.current !== O; Y.current && (e || t || r) && (e && (Z.current = o), t && (X.current = M), r && (V.current = O), T.getState().updateNodeDimensions([{ id: n, nodeElement: Y.current, forceUpdate: !0 }])) }), [n, o, M, O]); const ee = Kt({ nodeRef: Y, disabled: I || !v, noDragClassName: $, handleSelector: D, nodeId: n, isSelectable: E, selectNodesOnDrag: w }); return I ? null : e("div", { className: g(["react-flow__node", `react-flow__node-${o}`, { [z]: v }, x, { selected: u, selectable: E, parent: B, dragging: ee }]), ref: Y, style: { zIndex: A, transform: `translate(${l}px,${c}px)`, pointerEvents: K ? "all" : "none", visibility: _ ? "visible" : "hidden", ...b }, "data-id": n, "data-testid": `rf__node-${n}`, onMouseEnter: G, onMouseMove: j, onMouseLeave: q, onContextMenu: Q, onClick: e => { if (!E || w && v || Xt({ id: n, store: T, nodeRef: Y }), h) { const t = T.getState().nodeInternals.get(n); h(e, { ...t }) } }, onDoubleClick: J, onKeyDown: N ? e => { if (!W(e)) if (F.includes(e.key) && E) { const t = "Escape" === e.key; Xt({ id: n, store: T, unselect: t, nodeRef: Y }) } else !L && v && u && Object.prototype.hasOwnProperty.call(Ft, e.key) && (T.setState({ ariaLiveMessage: `Moved selected node ${e.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~a}, y: ${~~i}` }), U({ x: Ft[e.key].x, y: Ft[e.key].y, isShiftPressed: e.shiftKey })) } : void 0, tabIndex: N ? 0 : void 0, role: N ? "button" : void 0, "aria-describedby": L ? void 0 : `${bt}-${H}`, "aria-label": R, children: e(Ne, { value: n, children: e(t, { id: n, data: r, type: o, xPos: a, yPos: i, selected: u, isConnectable: C, sourcePosition: M, targetPosition: O, dragging: ee, dragHandle: D, zIndex: A }) }) }) }; return n.displayName = "NodeWrapper", r(n) }; function Gt(e) { return { ...{ input: Wt(e.input || ot), default: Wt(e.default || tt), output: Wt(e.output || at), group: Wt(e.group || it) }, ...Object.keys(e).filter((e => !["input", "default", "output", "group"].includes(e))).reduce(((t, n) => (t[n] = Wt(e[n] || tt), t)), {}) } } const jt = "undefined" != typeof document ? document : null; var qt = (e = null, t = { target: jt }) => { const [n, o] = c(!1), r = d(!1), i = d(new Set([])), [l, u] = a((() => { if (null !== e) { const t = (Array.isArray(e) ? e : [e]).filter((e => "string" == typeof e)).map((e => e.split("+"))), n = t.reduce(((e, t) => e.concat(...t)), []); return [t, n] } return [[], []] }), [e]); return s((() => { if (null !== e) { const e = e => { if (r.current = e.ctrlKey || e.metaKey || e.shiftKey, !r.current && W(e)) return !1; const t = Jt(e.code, u); i.current.add(e[t]), Qt(l, i.current, !1) && (e.preventDefault(), o(!0)) }, n = e => { if (!r.current && W(e)) return !1; const t = Jt(e.code, u); Qt(l, i.current, !0) ? (o(!1), i.current.clear()) : i.current.delete(e[t]), r.current = !1 }, a = () => { i.current.clear(), o(!1) }; return t?.target?.addEventListener("keydown", e), t?.target?.addEventListener("keyup", n), window.addEventListener("blur", a), () => { t?.target?.removeEventListener("keydown", e), t?.target?.removeEventListener("keyup", n), window.removeEventListener("blur", a) } } }), [e, o]), n }; function Qt(e, t, n) { return e.filter((e => n || e.length === t.size)).some((e => e.every((e => t.has(e))))) } function Jt(e, t) { return t.includes(e) ? "code" : "key" } function en(e, t, n, o) { if (!e.parentNode) return n; const r = t.get(e.parentNode), a = _e(r, o); return en(r, t, { x: (n.x ?? 0) + a.x, y: (n.y ?? 0) + a.y, z: (r[U]?.z ?? 0) > (n.z ?? 0) ? r[U]?.z ?? 0 : n.z ?? 0 }, o) } function tn(e, t, n) { e.forEach((o => { if (o.parentNode && !e.has(o.parentNode)) throw new Error(`Parent node ${o.parentNode} not found`); if (o.parentNode || n?.[o.id]) { const { x: r, y: a, z: i } = en(o, e, { ...o.position, z: o[U]?.z ?? 0 }, t); o.positionAbsolute = { x: r, y: a }, o[U].z = i, n?.[o.id] && (o[U].isParent = !0) } })) } function nn(e, t, n, o) { const r = new Map, a = {}, i = o ? 1e3 : 0; return e.forEach((e => { const n = (K(e.zIndex) ? e.zIndex : 0) + (e.selected ? i : 0), o = t.get(e.id), s = { width: o?.width, height: o?.height, ...e, positionAbsolute: { x: e.position.x, y: e.position.y } }; e.parentNode && (s.parentNode = e.parentNode, a[e.parentNode] = !0), Object.defineProperty(s, U, { enumerable: !1, value: { handleBounds: o?.[U]?.handleBounds, z: n } }), r.set(e.id, s) })), tn(r, n, a), r } function on(e, t = {}) { const { getNodes: n, width: o, height: r, minZoom: a, maxZoom: i, d3Zoom: s, d3Selection: d, fitViewOnInitDone: l, fitViewOnInit: c, nodeOrigin: u } = e(), g = t.initial && !l && c; if (s && d && (g || !t.initial)) { const e = n().filter((e => { const n = t.includeHiddenNodes ? e.width && e.height : !e.hidden; return t.nodes?.length ? n && t.nodes.some((t => t.id === e.id)) : n })), l = e.every((e => e.width && e.height)); if (e.length > 0 && l) { const n = Le(e, u), [l, c, g] = Te(n, o, r, t.minZoom ?? a, t.maxZoom ?? i, t.padding ?? .1), h = b.translate(l, c).scale(g); return "number" == typeof t.duration && t.duration > 0 ? s.transform(Ye(d, t.duration), h) : s.transform(d, h), !0 } } return !1 } function rn(e, t) { return e.forEach((e => { const n = t.get(e.id); n && t.set(n.id, { ...n, [U]: n[U], selected: e.selected }) })), new Map(t) } function an(e, t) { return t.map((t => { const n = e.find((e => e.id === t.id)); return n && (t.selected = n.selected), t })) } function sn({ changedNodes: e, changedEdges: t, get: n, set: o }) { const { nodeInternals: r, edges: a, onNodesChange: i, onEdgesChange: s, hasDefaultNodes: d, hasDefaultEdges: l } = n(); e?.length && (d && o({ nodeInternals: rn(e, r) }), i?.(e)), t?.length && (l && o({ edges: an(t, a) }), s?.(t)) } const dn = () => { }, ln = { zoomIn: dn, zoomOut: dn, zoomTo: dn, getZoom: () => 1, setViewport: dn, getViewport: () => ({ x: 0, y: 0, zoom: 1 }), fitView: () => !1, setCenter: dn, fitBounds: dn, project: e => e, viewportInitialized: !1 }, cn = e => ({ d3Zoom: e.d3Zoom, d3Selection: e.d3Selection }), un = () => { const e = P(), { d3Zoom: t, d3Selection: n } = M(cn, m), o = a((() => n && t ? { zoomIn: e => t.scaleBy(Ye(n, e?.duration), 1.2), zoomOut: e => t.scaleBy(Ye(n, e?.duration), 1 / 1.2), zoomTo: (e, o) => t.scaleTo(Ye(n, o?.duration), e), getZoom: () => e.getState().transform[2], setViewport: (o, r) => { const [a, i, s] = e.getState().transform, d = b.translate(o.x ?? a, o.y ?? i).scale(o.zoom ?? s); t.transform(Ye(n, r?.duration), d) }, getViewport: () => { const [t, n, o] = e.getState().transform; return { x: t, y: n, zoom: o } }, fitView: t => on(e.getState, t), setCenter: (o, r, a) => { const { width: i, height: s, maxZoom: d } = e.getState(), l = void 0 !== a?.zoom ? a.zoom : d, c = i / 2 - o * l, u = s / 2 - r * l, g = b.translate(c, u).scale(l); t.transform(Ye(n, a?.duration), g) }, fitBounds: (o, r) => { const { width: a, height: i, minZoom: s, maxZoom: d } = e.getState(), [l, c, u] = Te(o, a, i, s, d, r?.padding ?? .1), g = b.translate(l, c).scale(u); t.transform(Ye(n, r?.duration), g) }, project: t => { const { transform: n, snapToGrid: o, snapGrid: r } = e.getState(); return $e(t, n, o, r) }, viewportInitialized: !0 } : ln), [t, n]); return o }; function gn() { const e = un(), t = P(), n = u((() => t.getState().getNodes().map((e => ({ ...e })))), []), o = u((e => t.getState().nodeInternals.get(e)), []), r = u((() => { const { edges: e = [] } = t.getState(); return e.map((e => ({ ...e }))) }), []), i = u((e => { const { edges: n = [] } = t.getState(); return n.find((t => t.id === e)) }), []), s = u((e => { const { getNodes: n, setNodes: o, hasDefaultNodes: r, onNodesChange: a } = t.getState(), i = n(), s = "function" == typeof e ? e(i) : e; if (r) o(s); else if (a) { a(0 === s.length ? i.map((e => ({ type: "remove", id: e.id }))) : s.map((e => ({ item: e, type: "reset" })))) } }), []), d = u((e => { const { edges: n = [], setEdges: o, hasDefaultEdges: r, onEdgesChange: a } = t.getState(), i = "function" == typeof e ? e(n) : e; if (r) o(i); else if (a) { a(0 === i.length ? n.map((e => ({ type: "remove", id: e.id }))) : i.map((e => ({ item: e, type: "reset" })))) } }), []), l = u((e => { const n = Array.isArray(e) ? e : [e], { getNodes: o, setNodes: r, hasDefaultNodes: a, onNodesChange: i } = t.getState(); if (a) { r([...o(), ...n]) } else if (i) { i(n.map((e => ({ item: e, type: "add" })))) } }), []), c = u((e => { const n = Array.isArray(e) ? e : [e], { edges: o = [], setEdges: r, hasDefaultEdges: a, onEdgesChange: i } = t.getState(); if (a) r([...o, ...n]); else if (i) { i(n.map((e => ({ item: e, type: "add" })))) } }), []), g = u((() => { const { getNodes: e, edges: n = [], transform: o } = t.getState(), [r, a, i] = o; return { nodes: e().map((e => ({ ...e }))), edges: n.map((e => ({ ...e }))), viewport: { x: r, y: a, zoom: i } } }), []), h = u((({ nodes: e, edges: n }) => { const { nodeInternals: o, getNodes: r, edges: a, hasDefaultNodes: i, hasDefaultEdges: s, onNodesDelete: d, onEdgesDelete: l, onNodesChange: c, onEdgesChange: u } = t.getState(), g = (e || []).map((e => e.id)), h = (n || []).map((e => e.id)), p = r().reduce(((e, t) => { const n = !g.includes(t.id) && t.parentNode && e.find((e => e.id === t.parentNode)); return ("boolean" != typeof t.deletable || t.deletable) && (g.includes(t.id) || n) && e.push(t), e }), []), m = a.filter((e => "boolean" != typeof e.deletable || e.deletable)), y = m.filter((e => h.includes(e.id))); if (p || y) { const e = He(p, m), n = [...y, ...e], r = n.reduce(((e, t) => (e.includes(t.id) || e.push(t.id), e)), []); if ((s || i) && (s && t.setState({ edges: a.filter((e => !r.includes(e.id))) }), i && (p.forEach((e => { o.delete(e.id) })), t.setState({ nodeInternals: new Map(o) }))), r.length > 0 && (l?.(n), u && u(r.map((e => ({ id: e, type: "remove" }))))), p.length > 0 && (d?.(p), c)) { c(p.map((e => ({ id: e.id, type: "remove" })))) } } }), []), p = u((e => { const n = Z(e), o = n ? null : t.getState().nodeInternals.get(e.id); return [n ? e : Y(o), o, n] }), []), m = u(((e, n = !0, o) => { const [r, a, i] = p(e); return r ? (o || t.getState().getNodes()).filter((t => { if (!(i || t.id !== a.id && t.positionAbsolute)) return !1; const o = Y(t), s = V(o, r); return n && s > 0 || s >= e.width * e.height })) : [] }), []), y = u(((e, t, n = !0) => { const [o] = p(e); if (!o) return !1; const r = V(o, t); return n && r > 0 || r >= e.width * e.height }), []); return a((() => ({ ...e, getNodes: n, getNode: o, getEdges: r, getEdge: i, setNodes: s, setEdges: d, addNodes: l, addEdges: c, toObject: g, deleteElements: h, getIntersectingNodes: m, isNodeIntersecting: y })), [e, n, o, r, i, s, d, l, c, g, h, m, y]) } const hn = { position: "absolute", width: "100%", height: "100%", top: 0, left: 0 }, pn = e => ({ x: e.x, y: e.y, zoom: e.k }), mn = (e, t) => e.target.closest(`.${t}`), yn = (e, t) => 2 === t && Array.isArray(e) && e.includes(2), fn = e => ({ d3Zoom: e.d3Zoom, d3Selection: e.d3Selection, d3ZoomHandler: e.d3ZoomHandler, userSelectionActive: e.userSelectionActive }), Sn = ({ onMove: t, onMoveStart: n, onMoveEnd: o, onPaneContextMenu: r, zoomOnScroll: a = !0, zoomOnPinch: i = !0, panOnScroll: l = !1, panOnScrollSpeed: c = .5, panOnScrollMode: u = oe.Free, zoomOnDoubleClick: g = !0, elementsSelectable: h, panOnDrag: p = !0, defaultViewport: y, translateExtent: v, minZoom: E, maxZoom: C, zoomActivationKeyCode: w, preventScrolling: O = !0, children: I, noWheelClassName: k, noPanClassName: D }) => { const $ = d(), z = P(), _ = d(!1), L = d(!1), R = d(null), H = d({ x: 0, y: 0, zoom: 0 }), { d3Zoom: T, d3Selection: Y, d3ZoomHandler: X, userSelectionActive: V } = M(fn, m), Z = qt(w), K = d(0); return function (e) { const t = P(); s((() => { let n; const o = () => { if (!e.current) return; const n = A(e.current); 0 !== n.height && 0 !== n.width || t.getState().onError?.("004", N.error004()), t.setState({ width: n.width || 500, height: n.height || 500 }) }; return o(), window.addEventListener("resize", o), e.current && (n = new ResizeObserver((() => o())), n.observe(e.current)), () => { window.removeEventListener("resize", o), n && e.current && n.unobserve(e.current) } }), []) }(R), s((() => { if (R.current) { const e = R.current.getBoundingClientRect(), t = x().scaleExtent([E, C]).translateExtent(v), n = f(R.current).call(t), o = b.translate(y.x, y.y).scale(B(y.zoom, E, C)), r = [[0, 0], [e.width, e.height]], a = t.constrain()(o, r, v); t.transform(n, a), z.setState({ d3Zoom: t, d3Selection: n, d3ZoomHandler: n.on("wheel.zoom"), transform: [a.x, a.y, a.k], domNode: R.current.closest(".react-flow") }) } }), []), s((() => { Y && T && (!l || Z || V ? void 0 !== X && Y.on("wheel.zoom", (function (e, t) { if (!O || mn(e, k)) return null; e.preventDefault(), X.call(this, e, t) }), { passive: !1 }) : Y.on("wheel.zoom", (e => { if (mn(e, k)) return !1; e.preventDefault(), e.stopImmediatePropagation(); const t = Y.property("__zoom").k || 1; if (e.ctrlKey && i) { const n = S(e), o = -e.deltaY * (1 === e.deltaMode ? .05 : e.deltaMode ? 1 : .002) * 10, r = t * Math.pow(2, o); return void T.scaleTo(Y, r, n) } const n = 1 === e.deltaMode ? 20 : 1, o = u === oe.Vertical ? 0 : e.deltaX * n, r = u === oe.Horizontal ? 0 : e.deltaY * n; T.translateBy(Y, -o / t * c, -r / t * c) }), { passive: !1 })) }), [V, l, u, Y, T, X, Z, i, O, k]), s((() => { T && T.on("start", (e => { if (!e.sourceEvent) return null; K.current = e.sourceEvent.button; const { onViewportChangeStart: t } = z.getState(); if (_.current = !0, "mousedown" === e.sourceEvent?.type && z.setState({ paneDragging: !0 }), n || t) { const o = pn(e.transform); H.current = o, t?.(o), n?.(e.sourceEvent, o) } })) }), [T, n]), s((() => { T && (V && !_.current ? T.on("zoom", null) : V || T.on("zoom", (e => { const { onViewportChange: n } = z.getState(); if (z.setState({ transform: [e.transform.x, e.transform.y, e.transform.k] }), L.current = !(!r || !yn(p, K.current ?? 0)), t || n) { const o = pn(e.transform); n?.(o), t?.(e.sourceEvent, o) } }))) }), [V, T, t, p, r]), s((() => { T && T.on("end", (e => { if (!e.sourceEvent) return null; const { onViewportChangeEnd: t } = z.getState(); if (_.current = !1, z.setState({ paneDragging: !1 }), r && yn(p, K.current ?? 0) && !L.current && r(e.sourceEvent), L.current = !1, (o || t) && (n = H.current, a = e.transform, n.x !== a.x || n.y !== a.y || n.zoom !== a.k)) { const n = pn(e.transform); H.current = n, clearTimeout($.current), $.current = setTimeout((() => { t?.(n), o?.(e.sourceEvent, n) }), l ? 150 : 0) } var n, a })) }), [T, l, p, o, r]), s((() => { T && T.filter((e => { const t = Z || a, n = i && e.ctrlKey; if (1 === e.button && "mousedown" === e.type && (mn(e, "react-flow__node") || mn(e, "react-flow__edge"))) return !0; if (!(p || t || l || g || i)) return !1; if (V) return !1; if (!g && "dblclick" === e.type) return !1; if (mn(e, k) && "wheel" === e.type) return !1; if (mn(e, D) && "wheel" !== e.type) return !1; if (!i && e.ctrlKey && "wheel" === e.type) return !1; if (!t && !l && !n && "wheel" === e.type) return !1; if (!p && ("mousedown" === e.type || "touchstart" === e.type)) return !1; if (Array.isArray(p) && !p.includes(e.button) && ("mousedown" === e.type || "touchstart" === e.type)) return !1; const o = Array.isArray(p) && p.includes(e.button) || !e.button || e.button <= 1; return (!e.ctrlKey || "wheel" === e.type) && o })) }), [V, T, a, i, l, g, p, h, Z]), e("div", { className: "react-flow__renderer", ref: R, style: hn, children: I }) }, bn = e => ({ userSelectionActive: e.userSelectionActive, userSelectionRect: e.userSelectionRect }); function xn() { const { userSelectionActive: t, userSelectionRect: n } = M(bn, m); return t && n ? e("div", { className: "react-flow__selection react-flow__container", style: { width: n.width, height: n.height, transform: `translate(${n.x}px, ${n.y}px)` } }) : null } function vn(e, t) { const n = e.find((e => e.id === t.parentNode)); if (n) { const e = t.position.x + t.width - n.width, o = t.position.y + t.height - n.height; if (e > 0 || o > 0 || t.position.x < 0 || t.position.y < 0) { if (n.style = { ...n.style } || {}, n.style.width = n.style.width ?? n.width, n.style.height = n.style.height ?? n.height, e > 0 && (n.style.width += e), o > 0 && (n.style.height += o), t.position.x < 0) { const e = Math.abs(t.position.x); n.position.x = n.position.x - e, n.style.width += e, t.position.x = 0 } if (t.position.y < 0) { const e = Math.abs(t.position.y); n.position.y = n.position.y - e, n.style.height += e, t.position.y = 0 } n.width = n.style.width, n.height = n.style.height } } } function En(e, t) { if (e.some((e => "reset" === e.type))) return e.filter((e => "reset" === e.type)).map((e => e.item)); const n = e.filter((e => "add" === e.type)).map((e => e.item)); return t.reduce(((t, n) => { const o = e.filter((e => e.id === n.id)); if (0 === o.length) return t.push(n), t; const r = { ...n }; for (const e of o) if (e) switch (e.type) { case "select": r.selected = e.selected; break; case "position": void 0 !== e.position && (r.position = e.position), void 0 !== e.positionAbsolute && (r.positionAbsolute = e.positionAbsolute), void 0 !== e.dragging && (r.dragging = e.dragging), r.expandParent && vn(t, r); break; case "dimensions": void 0 !== e.dimensions && (r.width = e.dimensions.width, r.height = e.dimensions.height), void 0 !== e.updateStyle && (r.style = { ...r.style || {}, ...e.dimensions }), "boolean" == typeof e.resizing && (r.resizing = e.resizing), r.expandParent && vn(t, r); break; case "remove": return t }return t.push(r), t }), n) } function Cn(e, t) { return En(e, t) } function Nn(e, t) { return En(e, t) } const wn = (e, t) => ({ id: e, type: "select", selected: t }); function Mn(e, t) { return e.reduce(((e, n) => { const o = t.includes(n.id); return !n.selected && o ? (n.selected = !0, e.push(wn(n.id, !0))) : n.selected && !o && (n.selected = !1, e.push(wn(n.id, !1))), e }), []) } const Pn = (e, t) => n => { n.target === t.current && e?.(n) }, On = e => ({ userSelectionActive: e.userSelectionActive, elementsSelectable: e.elementsSelectable, dragging: e.paneDragging }), In = r((({ isSelecting: n, selectionMode: o = re.Full, panOnDrag: r, onSelectionStart: a, onSelectionEnd: i, onPaneClick: s, onPaneContextMenu: l, onPaneScroll: c, onPaneMouseEnter: u, onPaneMouseMove: h, onPaneMouseLeave: p, children: y }) => { const f = d(null), S = P(), b = d(0), x = d(0), v = d(), { userSelectionActive: E, elementsSelectable: C, dragging: N } = M(On, m), w = () => { S.setState({ userSelectionActive: !1, userSelectionRect: null }), b.current = 0, x.current = 0 }, O = e => { s?.(e), S.getState().resetSelectedElements(), S.setState({ nodesSelectionActive: !1 }) }, I = c ? e => c(e) : void 0, k = C && (n || E); return t("div", { className: g(["react-flow__pane", { dragging: N, selection: n }]), onClick: k ? void 0 : Pn(O, f), onContextMenu: Pn((e => { Array.isArray(r) && r?.includes(2) ? e.preventDefault() : l?.(e) }), f), onWheel: Pn(I, f), onMouseEnter: k ? void 0 : u, onMouseDown: k ? e => { const { resetSelectedElements: t, domNode: o } = S.getState(); if (v.current = o?.getBoundingClientRect(), !C || !n || 0 !== e.button || e.target !== f.current || !v.current) return; const { x: r, y: i } = j(e, v.current); t(), S.setState({ userSelectionRect: { width: 0, height: 0, startX: r, startY: i, x: r, y: i } }), a?.(e) } : void 0, onMouseMove: k ? e => { const { userSelectionRect: t, nodeInternals: r, edges: a, transform: i, onNodesChange: s, onEdgesChange: d, nodeOrigin: l, getNodes: c } = S.getState(); if (!n || !v.current || !t) return; S.setState({ userSelectionActive: !0, nodesSelectionActive: !1 }); const u = j(e, v.current), g = t.startX ?? 0, h = t.startY ?? 0, p = { ...t, x: u.x < g ? u.x : g, y: u.y < h ? u.y : h, width: Math.abs(u.x - g), height: Math.abs(u.y - h) }, m = c(), y = Re(r, p, i, o === re.Partial, !0, l), f = He(y, a).map((e => e.id)), E = y.map((e => e.id)); if (b.current !== E.length) { b.current = E.length; const e = Mn(m, E); e.length && s?.(e) } if (x.current !== f.length) { x.current = f.length; const e = Mn(a, f); e.length && d?.(e) } S.setState({ userSelectionRect: p }) } : h, onMouseUp: k ? e => { if (0 !== e.button) return; const { userSelectionRect: t } = S.getState(); !E && t && e.target === f.current && O?.(e), S.setState({ nodesSelectionActive: b.current > 0 }), w(), i?.(e) } : void 0, onMouseLeave: k ? e => { E && (S.setState({ nodesSelectionActive: b.current > 0 }), i?.(e)), w() } : p, ref: f, style: hn, children: [y, e(xn, {})] }) })); In.displayName = "Pane"; const kn = e => { const t = e.getNodes().filter((e => e.selected)); return { ...Le(t, e.nodeOrigin), transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`, userSelectionActive: e.userSelectionActive } }; var Dn = r((function ({ onSelectionContextMenu: t, noPanClassName: n, disableKeyboardA11y: o }) { const r = P(), { width: a, height: i, x: l, y: c, transformString: u, userSelectionActive: h } = M(kn, m), p = Ut(), y = d(null); if (s((() => { o || y.current?.focus({ preventScroll: !0 }) }), [o]), Kt({ nodeRef: y }), h || !a || !i) return null; const f = t ? e => { const n = r.getState().getNodes().filter((e => e.selected)); t(e, n) } : void 0; return e("div", { className: g(["react-flow__nodesselection", "react-flow__container", n]), style: { transform: u }, children: e("div", { ref: y, className: "react-flow__nodesselection-rect", onContextMenu: f, tabIndex: o ? void 0 : -1, onKeyDown: o ? void 0 : e => { Object.prototype.hasOwnProperty.call(Ft, e.key) && p({ x: Ft[e.key].x, y: Ft[e.key].y, isShiftPressed: e.shiftKey }) }, style: { width: a, height: i, top: c, left: l } }) }) })); const An = e => e.nodesSelectionActive, Bn = ({ children: n, onPaneClick: o, onPaneMouseEnter: r, onPaneMouseMove: a, onPaneMouseLeave: i, onPaneContextMenu: d, onPaneScroll: l, deleteKeyCode: c, onMove: u, onMoveStart: g, onMoveEnd: h, selectionKeyCode: p, selectionOnDrag: m, selectionMode: y, onSelectionStart: f, onSelectionEnd: S, multiSelectionKeyCode: b, panActivationKeyCode: x, zoomActivationKeyCode: v, elementsSelectable: E, zoomOnScroll: C, zoomOnPinch: N, panOnScroll: w, panOnScrollSpeed: O, panOnScrollMode: I, zoomOnDoubleClick: k, panOnDrag: D, defaultViewport: A, translateExtent: B, minZoom: $, maxZoom: z, preventScrolling: _, onSelectionContextMenu: L, noWheelClassName: R, noPanClassName: H, disableKeyboardA11y: T }) => { const Y = M(An), X = qt(p), V = qt(x) || D, Z = X || m && !0 !== V; return (({ deleteKeyCode: e, multiSelectionKeyCode: t }) => { const n = P(), { deleteElements: o } = gn(), r = qt(e), a = qt(t); s((() => { if (r) { const { edges: e, getNodes: t } = n.getState(), r = t().filter((e => e.selected)), a = e.filter((e => e.selected)); o({ nodes: r, edges: a }), n.setState({ nodesSelectionActive: !1 }) } }), [r]), s((() => { n.setState({ multiSelectionActive: a }) }), [a]) })({ deleteKeyCode: c, multiSelectionKeyCode: b }), e(Sn, { onMove: u, onMoveStart: g, onMoveEnd: h, onPaneContextMenu: d, elementsSelectable: E, zoomOnScroll: C, zoomOnPinch: N, panOnScroll: w, panOnScrollSpeed: O, panOnScrollMode: I, zoomOnDoubleClick: k, panOnDrag: !X && V, defaultViewport: A, translateExtent: B, minZoom: $, maxZoom: z, zoomActivationKeyCode: v, preventScrolling: _, noWheelClassName: R, noPanClassName: H, children: t(In, { onSelectionStart: f, onSelectionEnd: S, onPaneClick: o, onPaneMouseEnter: r, onPaneMouseMove: a, onPaneMouseLeave: i, onPaneContextMenu: d, onPaneScroll: l, panOnDrag: V, isSelecting: !!Z, selectionMode: y, children: [n, Y && e(Dn, { onSelectionContextMenu: L, noPanClassName: H, disableKeyboardA11y: T })] }) }) }; Bn.displayName = "FlowRenderer"; var $n = r(Bn); const zn = e => ({ nodesDraggable: e.nodesDraggable, nodesConnectable: e.nodesConnectable, nodesFocusable: e.nodesFocusable, elementsSelectable: e.elementsSelectable, updateNodeDimensions: e.updateNodeDimensions, onError: e.onError }), _n = t => { const { nodesDraggable: n, nodesConnectable: o, nodesFocusable: r, elementsSelectable: i, updateNodeDimensions: l, onError: c } = M(zn, m), g = (h = t.onlyRenderVisibleElements, M(u((e => h ? Re(e.nodeInternals, { x: 0, y: 0, width: e.width, height: e.height }, e.transform, !0) : e.getNodes()), [h]))); var h; const p = d(), y = a((() => { if ("undefined" == typeof ResizeObserver) return null; const e = new ResizeObserver((e => { const t = e.map((e => ({ id: e.target.getAttribute("data-id"), nodeElement: e.target, forceUpdate: !0 }))); l(t) })); return p.current = e, e }), []); return s((() => () => { p?.current?.disconnect() }), []), e("div", { className: "react-flow__nodes", style: hn, children: g.map((a => { let s = a.type || "default"; t.nodeTypes[s] || (c?.("003", N.error003(s)), s = "default"); const d = t.nodeTypes[s] || t.nodeTypes.default, l = !!(a.draggable || n && void 0 === a.draggable), u = !!(a.selectable || i && void 0 === a.selectable), g = !!(a.connectable || o && void 0 === a.connectable), h = !!(a.focusable || r && void 0 === a.focusable), p = t.nodeExtent ? $(a.positionAbsolute, t.nodeExtent) : a.positionAbsolute, m = p?.x ?? 0, f = p?.y ?? 0, S = (({ x: e, y: t, width: n, height: o, origin: r }) => n && o ? r[0] < 0 || r[1] < 0 || r[0] > 1 || r[1] > 1 ? { x: e, y: t } : { x: e - n * r[0], y: t - o * r[1] } : { x: e, y: t })({ x: m, y: f, width: a.width ?? 0, height: a.height ?? 0, origin: t.nodeOrigin }); return e(d, { id: a.id, className: a.className, style: a.style, type: s, data: a.data, sourcePosition: a.sourcePosition || se.Bottom, targetPosition: a.targetPosition || se.Top, hidden: a.hidden, xPos: m, yPos: f, xPosOrigin: S.x, yPosOrigin: S.y, selectNodesOnDrag: t.selectNodesOnDrag, onClick: t.onNodeClick, onMouseEnter: t.onNodeMouseEnter, onMouseMove: t.onNodeMouseMove, onMouseLeave: t.onNodeMouseLeave, onContextMenu: t.onNodeContextMenu, onDoubleClick: t.onNodeDoubleClick, selected: !!a.selected, isDraggable: l, isSelectable: u, isConnectable: g, isFocusable: h, resizeObserver: y, dragHandle: a.dragHandle, zIndex: a[U]?.z ?? 0, isParent: !!a[U]?.isParent, noDragClassName: t.noDragClassName, noPanClassName: t.noPanClassName, initialized: !!a.width && !!a.height, rfId: t.rfId, disableKeyboardA11y: t.disableKeyboardA11y, ariaLabel: a.ariaLabel }, a.id) })) }) }; _n.displayName = "NodeRenderer"; var Ln = r(_n); const Rn = [{ level: 0, isMaxLevel: !0, edges: [] }]; function Hn(e, t, n) { return function (e, t, n = !1) { let o = -1; const r = e.reduce(((e, r) => { const a = K(r.zIndex); let i = a ? r.zIndex : 0; if (n) { const e = t.get(r.target), n = t.get(r.source), o = r.selected || e?.selected || n?.selected, s = Math.max(n?.[U]?.z || 0, e?.[U]?.z || 0, 1e3); i = (a ? r.zIndex : 0) + (o ? s : 0) } return e[i] ? e[i].push(r) : e[i] = [r], o = i > o ? i : o, e }), {}), a = Object.entries(r).map((([e, t]) => { const n = +e; return { edges: t, level: n, isMaxLevel: n === o } })); return 0 === a.length ? Rn : a }(M(u((n => e ? n.edges.filter((e => { const o = t.get(e.source), r = t.get(e.target); return o?.width && o?.height && r?.width && r?.height && function ({ sourcePos: e, targetPos: t, sourceWidth: n, sourceHeight: o, targetWidth: r, targetHeight: a, width: i, height: s, transform: d }) { const l = { x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), x2: Math.max(e.x + n, t.x + r), y2: Math.max(e.y + o, t.y + a) }; l.x === l.x2 && (l.x2 += 1), l.y === l.y2 && (l.y2 += 1); const c = H({ x: (0 - d[0]) / d[2], y: (0 - d[1]) / d[2], width: i / d[2], height: s / d[2] }), u = Math.max(0, Math.min(c.x2, l.x2) - Math.max(c.x, l.x)), g = Math.max(0, Math.min(c.y2, l.y2) - Math.max(c.y, l.y)); return Math.ceil(u * g) > 0 }({ sourcePos: o.positionAbsolute || { x: 0, y: 0 }, targetPos: r.positionAbsolute || { x: 0, y: 0 }, sourceWidth: o.width, sourceHeight: o.height, targetWidth: r.width, targetHeight: r.height, width: n.width, height: n.height, transform: n.transform }) })) : n.edges), [e, t])), t, n) } const Tn = { [ie.Arrow]: ({ color: t = "none", strokeWidth: n = 1 }) => e("polyline", { stroke: t, strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: n, fill: "none", points: "-5,-4 0,0 -5,4" }), [ie.ArrowClosed]: ({ color: t = "none", strokeWidth: n = 1 }) => e("polyline", { stroke: t, strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: n, fill: t, points: "-5,-4 0,0 -5,4 -5,-4" }) }; const Yn = ({ id: t, type: n, color: o, width: r = 12.5, height: i = 12.5, markerUnits: s = "strokeWidth", strokeWidth: d, orient: l = "auto-start-reverse" }) => { const c = function (e) { const t = P(); return a((() => Object.prototype.hasOwnProperty.call(Tn, e) ? Tn[e] : (t.getState().onError?.("009", N.error009(e)), null)), [e]) }(n); return c ? e("marker", { className: "react-flow__arrowhead", id: t, markerWidth: `${r}`, markerHeight: `${i}`, viewBox: "-10 -10 20 20", markerUnits: s, orient: l, refX: "0", refY: "0", children: e(c, { color: o, strokeWidth: d }) }) : null }, Xn = ({ defaultColor: t, rfId: n }) => { const o = M(u((({ defaultColor: e, rfId: t }) => n => { const o = []; return n.edges.reduce(((n, r) => ([r.markerStart, r.markerEnd].forEach((r => { if (r && "object" == typeof r) { const a = De(r, t); o.includes(a) || (n.push({ id: a, color: r.color || e, ...r }), o.push(a)) } })), n)), []).sort(((e, t) => e.id.localeCompare(t.id))) })({ defaultColor: t, rfId: n }), [t, n]), ((e, t) => !(e.length !== t.length || e.some(((e, n) => e.id !== t[n].id))))); return e("defs", { children: o.map((t => e(Yn, { id: t.id, type: t.type, color: t.color, width: t.width, height: t.height, markerUnits: t.markerUnits, strokeWidth: t.strokeWidth, orient: t.orient }, t.id))) }) }; Xn.displayName = "MarkerDefinitions"; var Vn = r(Xn); const Zn = e => ({ nodesConnectable: e.nodesConnectable, edgesFocusable: e.edgesFocusable, edgesUpdatable: e.edgesUpdatable, elementsSelectable: e.elementsSelectable, width: e.width, height: e.height, connectionMode: e.connectionMode, nodeInternals: e.nodeInternals, onError: e.onError }), Kn = ({ defaultMarkerColor: o, onlyRenderVisibleElements: r, elevateEdgesOnSelect: a, rfId: i, edgeTypes: s, noPanClassName: d, onEdgeUpdate: l, onEdgeContextMenu: c, onEdgeMouseEnter: u, onEdgeMouseMove: h, onEdgeMouseLeave: p, onEdgeClick: y, edgeUpdaterRadius: f, onEdgeDoubleClick: S, onEdgeUpdateStart: b, onEdgeUpdateEnd: x, children: v }) => { const { edgesFocusable: E, edgesUpdatable: C, elementsSelectable: w, width: P, height: O, connectionMode: I, nodeInternals: k, onError: D } = M(Zn, m), A = Hn(r, k, a); return P ? t(n, { children: [A.map((({ level: n, edges: r, isMaxLevel: a }) => t("svg", { style: { zIndex: n }, width: P, height: O, className: "react-flow__edges react-flow__container", children: [a && e(Vn, { defaultColor: o, rfId: i }), e("g", { children: r.map((t => { const [n, o, r] = $t(k.get(t.source)), [a, m, v] = $t(k.get(t.target)); if (!r || !v) return null; let M = t.type || "default"; s[M] || (D?.("011", N.error011(M)), M = "default"); const P = s[M] || s.default, O = I === ne.Strict ? m.target : (m.target ?? []).concat(m.source ?? []), A = Bt(o.source, t.sourceHandle), B = Bt(O, t.targetHandle), $ = A?.position || se.Bottom, z = B?.position || se.Top, _ = !!(t.focusable || E && void 0 === t.focusable), L = void 0 !== l && (t.updatable || C && void 0 === t.updatable); if (!A || !B) return D?.("008", N.error008(A, t)), null; const { sourceX: R, sourceY: H, targetX: T, targetY: Y } = ((e, t, n, o, r, a) => { const i = At(n, e, t), s = At(a, o, r); return { sourceX: i.x, sourceY: i.y, targetX: s.x, targetY: s.y } })(n, A, $, a, B, z); return e(P, { id: t.id, className: g([t.className, d]), type: M, data: t.data, selected: !!t.selected, animated: !!t.animated, hidden: !!t.hidden, label: t.label, labelStyle: t.labelStyle, labelShowBg: t.labelShowBg, labelBgStyle: t.labelBgStyle, labelBgPadding: t.labelBgPadding, labelBgBorderRadius: t.labelBgBorderRadius, style: t.style, source: t.source, target: t.target, sourceHandleId: t.sourceHandle, targetHandleId: t.targetHandle, markerEnd: t.markerEnd, markerStart: t.markerStart, sourceX: R, sourceY: H, targetX: T, targetY: Y, sourcePosition: $, targetPosition: z, elementsSelectable: w, onEdgeUpdate: l, onContextMenu: c, onMouseEnter: u, onMouseMove: h, onMouseLeave: p, onClick: y, edgeUpdaterRadius: f, onEdgeDoubleClick: S, onEdgeUpdateStart: b, onEdgeUpdateEnd: x, rfId: i, ariaLabel: t.ariaLabel, isFocusable: _, isUpdatable: L, pathOptions: "pathOptions" in t ? t.pathOptions : void 0, interactionWidth: t.interactionWidth }, t.id) })) })] }, n))), v] }) : null }; Kn.displayName = "EdgeRenderer"; var Un = r(Kn); const Fn = e => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`; function Wn({ children: t }) { const n = M(Fn); return e("div", { className: "react-flow__viewport react-flow__container", style: { transform: n }, children: t }) } const Gn = { [se.Left]: se.Right, [se.Right]: se.Left, [se.Top]: se.Bottom, [se.Bottom]: se.Top }, jn = ({ nodeId: t, handleType: n, style: o, type: r = ae.Bezier, CustomComponent: a, connectionStatus: i }) => { const { fromNode: s, handleId: d, toX: l, toY: c, connectionMode: g } = M(u((e => ({ fromNode: e.nodeInternals.get(t), handleId: e.connectionHandleId, toX: (e.connectionPosition.x - e.transform[0]) / e.transform[2], toY: (e.connectionPosition.y - e.transform[1]) / e.transform[2], connectionMode: e.connectionMode })), [t]), m), h = s?.[U]?.handleBounds; let p = h?.[n]; if (g === ne.Loose && (p = p || h?.["source" === n ? "target" : "source"]), !s || !p) return null; const y = d ? p.find((e => e.id === d)) : p[0], f = y ? y.x + y.width / 2 : (s.width ?? 0) / 2, S = y ? y.y + y.height / 2 : s.height ?? 0, b = (s.positionAbsolute?.x ?? 0) + f, x = (s.positionAbsolute?.y ?? 0) + S, v = y?.position, E = v ? Gn[v] : null; if (!v || !E) return null; if (a) return e(a, { connectionLineType: r, connectionLineStyle: o, fromNode: s, fromHandle: y, fromX: b, fromY: x, toX: l, toY: c, fromPosition: v, toPosition: E, connectionStatus: i }); let C = ""; const N = { sourceX: b, sourceY: x, sourcePosition: v, targetX: l, targetY: c, targetPosition: E }; return r === ae.Bezier ? [C] = ve(N) : r === ae.Step ? [C] = pe({ ...N, borderRadius: 0 }) : r === ae.SmoothStep ? [C] = pe(N) : r === ae.SimpleBezier ? [C] = le(N) : C = `M${b},${x} ${l},${c}`, e("path", { d: C, fill: "none", className: "react-flow__connection-path", style: o }) }; jn.displayName = "ConnectionLine"; const qn = e => ({ nodeId: e.connectionNodeId, handleType: e.connectionHandleType, nodesConnectable: e.nodesConnectable, connectionStatus: e.connectionStatus, width: e.width, height: e.height }); function Qn({ containerStyle: t, style: n, type: o, component: r }) { const { nodeId: a, handleType: i, nodesConnectable: s, width: d, height: l, connectionStatus: c } = M(qn, m); return !!(a && i && d && s) ? e("svg", { style: t, width: d, height: l, className: "react-flow__edges react-flow__connectionline react-flow__container", children: e("g", { className: g(["react-flow__connection", c]), children: e(jn, { nodeId: a, handleType: i, style: n, type: o, CustomComponent: r, connectionStatus: c }) }) }) : null } const Jn = ({ nodeTypes: n, edgeTypes: o, onMove: r, onMoveStart: a, onMoveEnd: i, onInit: l, onNodeClick: c, onEdgeClick: u, onNodeDoubleClick: g, onEdgeDoubleClick: h, onNodeMouseEnter: p, onNodeMouseMove: m, onNodeMouseLeave: y, onNodeContextMenu: f, onSelectionContextMenu: S, onSelectionStart: b, onSelectionEnd: x, connectionLineType: v, connectionLineStyle: E, connectionLineComponent: C, connectionLineContainerStyle: N, selectionKeyCode: w, selectionOnDrag: M, selectionMode: P, multiSelectionKeyCode: O, panActivationKeyCode: I, zoomActivationKeyCode: k, deleteKeyCode: D, onlyRenderVisibleElements: A, elementsSelectable: B, selectNodesOnDrag: $, defaultViewport: z, translateExtent: _, minZoom: L, maxZoom: R, preventScrolling: H, defaultMarkerColor: T, zoomOnScroll: Y, zoomOnPinch: X, panOnScroll: V, panOnScrollSpeed: Z, panOnScrollMode: K, zoomOnDoubleClick: U, panOnDrag: F, onPaneClick: W, onPaneMouseEnter: G, onPaneMouseMove: j, onPaneMouseLeave: q, onPaneScroll: Q, onPaneContextMenu: J, onEdgeUpdate: ee, onEdgeContextMenu: te, onEdgeMouseEnter: ne, onEdgeMouseMove: oe, onEdgeMouseLeave: re, edgeUpdaterRadius: ae, onEdgeUpdateStart: ie, onEdgeUpdateEnd: se, noDragClassName: de, noWheelClassName: le, noPanClassName: ce, elevateEdgesOnSelect: ue, disableKeyboardA11y: ge, nodeOrigin: he, nodeExtent: pe, rfId: me }) => (function (e) { const t = gn(), n = d(!1); s((() => { !n.current && t.viewportInitialized && e && (setTimeout((() => e(t)), 1), n.current = !0) }), [e, t.viewportInitialized]) }(l), e($n, { onPaneClick: W, onPaneMouseEnter: G, onPaneMouseMove: j, onPaneMouseLeave: q, onPaneContextMenu: J, onPaneScroll: Q, deleteKeyCode: D, selectionKeyCode: w, selectionOnDrag: M, selectionMode: P, onSelectionStart: b, onSelectionEnd: x, multiSelectionKeyCode: O, panActivationKeyCode: I, zoomActivationKeyCode: k, elementsSelectable: B, onMove: r, onMoveStart: a, onMoveEnd: i, zoomOnScroll: Y, zoomOnPinch: X, zoomOnDoubleClick: U, panOnScroll: V, panOnScrollSpeed: Z, panOnScrollMode: K, panOnDrag: F, defaultViewport: z, translateExtent: _, minZoom: L, maxZoom: R, onSelectionContextMenu: S, preventScrolling: H, noDragClassName: de, noWheelClassName: le, noPanClassName: ce, disableKeyboardA11y: ge, children: t(Wn, { children: [e(Un, { edgeTypes: o, onEdgeClick: u, onEdgeDoubleClick: h, onEdgeUpdate: ee, onlyRenderVisibleElements: A, onEdgeContextMenu: te, onEdgeMouseEnter: ne, onEdgeMouseMove: oe, onEdgeMouseLeave: re, onEdgeUpdateStart: ie, onEdgeUpdateEnd: se, edgeUpdaterRadius: ae, defaultMarkerColor: T, noPanClassName: ce, elevateEdgesOnSelect: !!ue, disableKeyboardA11y: ge, rfId: me, children: e(Qn, { style: E, type: v, component: C, containerStyle: N }) }), e("div", { className: "react-flow__edgelabel-renderer" }), e(Ln, { nodeTypes: n, onNodeClick: c, onNodeDoubleClick: g, onNodeMouseEnter: p, onNodeMouseMove: m, onNodeMouseLeave: y, onNodeContextMenu: f, selectNodesOnDrag: $, onlyRenderVisibleElements: A, noPanClassName: ce, noDragClassName: de, disableKeyboardA11y: ge, nodeOrigin: he, nodeExtent: pe, rfId: me })] }) })); Jn.displayName = "GraphView"; var eo = r(Jn); const to = [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]], no = { rfId: "1", width: 0, height: 0, transform: [0, 0, 1], nodeInternals: new Map, edges: [], onNodesChange: null, onEdgesChange: null, hasDefaultNodes: !1, hasDefaultEdges: !1, d3Zoom: null, d3Selection: null, d3ZoomHandler: void 0, minZoom: .5, maxZoom: 2, translateExtent: to, nodeExtent: to, nodesSelectionActive: !1, userSelectionActive: !1, userSelectionRect: null, connectionNodeId: null, connectionHandleId: null, connectionHandleType: "source", connectionPosition: { x: 0, y: 0 }, connectionStatus: null, connectionMode: ne.Strict, domNode: null, paneDragging: !1, noPanClassName: "nopan", nodeOrigin: [0, 0], snapGrid: [15, 15], snapToGrid: !1, nodesDraggable: !0, nodesConnectable: !0, nodesFocusable: !0, edgesFocusable: !0, edgesUpdatable: !0, elementsSelectable: !0, elevateNodesOnSelect: !0, fitViewOnInit: !1, fitViewOnInitDone: !1, fitViewOnInitOptions: void 0, multiSelectionActive: !1, connectionStartHandle: null, connectionEndHandle: null, connectionClickStartHandle: null, connectOnClick: !0, ariaLiveMessage: "", autoPanOnConnect: !0, autoPanOnNodeDrag: !0, connectionRadius: 20, onError: (e, t) => { }, isValidConnection: void 0 }, oo = ({ children: t }) => { const n = d(null); return n.current || (n.current = p(((e, t) => ({ ...no, setNodes: n => { const { nodeInternals: o, nodeOrigin: r, elevateNodesOnSelect: a } = t(); e({ nodeInternals: nn(n, o, r, a) }) }, getNodes: () => Array.from(t().nodeInternals.values()), setEdges: n => { const { defaultEdgeOptions: o = {} } = t(); e({ edges: n.map((e => ({ ...o, ...e }))) }) }, setDefaultNodesAndEdges: (n, o) => { const r = void 0 !== n, a = void 0 !== o, i = r ? nn(n, new Map, t().nodeOrigin, t().elevateNodesOnSelect) : new Map; e({ nodeInternals: i, edges: a ? o : [], hasDefaultNodes: r, hasDefaultEdges: a }) }, updateNodeDimensions: n => { const { onNodesChange: o, nodeInternals: r, fitViewOnInit: a, fitViewOnInitDone: i, fitViewOnInitOptions: s, domNode: d, nodeOrigin: l } = t(), c = d?.querySelector(".react-flow__viewport"); if (!c) return; const u = window.getComputedStyle(c), { m22: g } = new window.DOMMatrixReadOnly(u.transform), h = n.reduce(((e, t) => { const n = r.get(t.id); if (n) { const o = A(t.nodeElement); o.width && o.height && (n.width !== o.width || n.height !== o.height || t.forceUpdate) && (r.set(n.id, { ...n, [U]: { ...n[U], handleBounds: { source: Tt(".source", t.nodeElement, g, l), target: Tt(".target", t.nodeElement, g, l) } }, ...o }), e.push({ id: n.id, type: "dimensions", dimensions: o })) } return e }), []); tn(r, l); const p = i || a && !i && on(t, { initial: !0, ...s }); e({ nodeInternals: new Map(r), fitViewOnInitDone: p }), h?.length > 0 && o?.(h) }, updateNodePositions: (e, n = !0, o = !1) => { const { triggerNodeChanges: r } = t(); r(e.map((e => { const t = { id: e.id, type: "position", dragging: o }; return n && (t.positionAbsolute = e.positionAbsolute, t.position = e.position), t }))) }, triggerNodeChanges: n => { const { onNodesChange: o, nodeInternals: r, hasDefaultNodes: a, nodeOrigin: i, getNodes: s, elevateNodesOnSelect: d } = t(); if (n?.length) { if (a) { const t = nn(Cn(n, s()), r, i, d); e({ nodeInternals: t }) } o?.(n) } }, addSelectedNodes: n => { const { multiSelectionActive: o, edges: r, getNodes: a } = t(); let i, s = null; o ? i = n.map((e => wn(e, !0))) : (i = Mn(a(), n), s = Mn(r, [])), sn({ changedNodes: i, changedEdges: s, get: t, set: e }) }, addSelectedEdges: n => { const { multiSelectionActive: o, edges: r, getNodes: a } = t(); let i, s = null; o ? i = n.map((e => wn(e, !0))) : (i = Mn(r, n), s = Mn(a(), [])), sn({ changedNodes: s, changedEdges: i, get: t, set: e }) }, unselectNodesAndEdges: ({ nodes: n, edges: o } = {}) => { const { edges: r, getNodes: a } = t(), i = o || r; sn({ changedNodes: (n || a()).map((e => (e.selected = !1, wn(e.id, !1)))), changedEdges: i.map((e => wn(e.id, !1))), get: t, set: e }) }, setMinZoom: n => { const { d3Zoom: o, maxZoom: r } = t(); o?.scaleExtent([n, r]), e({ minZoom: n }) }, setMaxZoom: n => { const { d3Zoom: o, minZoom: r } = t(); o?.scaleExtent([r, n]), e({ maxZoom: n }) }, setTranslateExtent: n => { t().d3Zoom?.translateExtent(n), e({ translateExtent: n }) }, resetSelectedElements: () => { const { edges: n, getNodes: o } = t(); sn({ changedNodes: o().filter((e => e.selected)).map((e => wn(e.id, !1))), changedEdges: n.filter((e => e.selected)).map((e => wn(e.id, !1))), get: t, set: e }) }, setNodeExtent: n => { const { nodeInternals: o } = t(); o.forEach((e => { e.positionAbsolute = $(e.position, n) })), e({ nodeExtent: n, nodeInternals: new Map(o) }) }, panBy: e => { const { transform: n, width: o, height: r, d3Zoom: a, d3Selection: i, translateExtent: s } = t(); if (!a || !i || !e.x && !e.y) return !1; const d = b.translate(n[0] + e.x, n[1] + e.y).scale(n[2]), l = [[0, 0], [o, r]], c = a?.constrain()(d, l, s); return a.transform(i, c), n[0] !== c.x || n[1] !== c.y || n[2] !== c.k }, cancelConnection: () => e({ connectionNodeId: no.connectionNodeId, connectionHandleId: no.connectionHandleId, connectionHandleType: no.connectionHandleType, connectionStatus: no.connectionStatus, connectionStartHandle: no.connectionStartHandle, connectionEndHandle: no.connectionEndHandle }), reset: () => e({ ...no }) })))), e(C, { value: n.current, children: t }) }; oo.displayName = "ReactFlowProvider"; const ro = ({ children: t }) => { const o = l(E); return e(o ? n : oo, { children: t }) }; function ao(e, t) { d(null); return a((() => t(e)), [e]) } ro.displayName = "ReactFlowWrapper"; const io = { input: ot, default: tt, output: at, group: it }, so = { default: Ee, straight: Se, step: ye, smoothstep: me, simplebezier: ce }, lo = [0, 0], co = [15, 15], uo = { x: 0, y: 0, zoom: 1 }, go = { width: "100%", height: "100%", overflow: "hidden", position: "relative", zIndex: 0 }, ho = i((({ nodes: n, edges: o, defaultNodes: r, defaultEdges: a, className: i, nodeTypes: s = io, edgeTypes: d = so, onNodeClick: l, onEdgeClick: c, onInit: u, onMove: h, onMoveStart: p, onMoveEnd: m, onConnect: y, onConnectStart: f, onConnectEnd: S, onClickConnectStart: b, onClickConnectEnd: x, onNodeMouseEnter: v, onNodeMouseMove: E, onNodeMouseLeave: C, onNodeContextMenu: N, onNodeDoubleClick: w, onNodeDragStart: M, onNodeDrag: P, onNodeDragStop: O, onNodesDelete: I, onEdgesDelete: D, onSelectionChange: A, onSelectionDragStart: B, onSelectionDrag: $, onSelectionDragStop: z, onSelectionContextMenu: _, onSelectionStart: L, onSelectionEnd: R, connectionMode: H = ne.Strict, connectionLineType: T = ae.Bezier, connectionLineStyle: Y, connectionLineComponent: X, connectionLineContainerStyle: V, deleteKeyCode: Z = "Backspace", selectionKeyCode: K = "Shift", selectionOnDrag: U = !1, selectionMode: F = re.Full, panActivationKeyCode: W = "Space", multiSelectionKeyCode: G = "Meta", zoomActivationKeyCode: j = "Meta", snapToGrid: q = !1, snapGrid: Q = co, onlyRenderVisibleElements: J = !1, selectNodesOnDrag: ee = !0, nodesDraggable: te, nodesConnectable: ie, nodesFocusable: se, nodeOrigin: de = lo, edgesFocusable: le, edgesUpdatable: ce, elementsSelectable: ue, defaultViewport: ge = uo, minZoom: he = .5, maxZoom: pe = 2, translateExtent: me = to, preventScrolling: ye = !0, nodeExtent: fe, defaultMarkerColor: Se = "#b1b1b7", zoomOnScroll: be = !0, zoomOnPinch: xe = !0, panOnScroll: ve = !1, panOnScrollSpeed: Ee = .5, panOnScrollMode: Ce = oe.Free, zoomOnDoubleClick: Ne = !0, panOnDrag: we = !0, onPaneClick: Me, onPaneMouseEnter: Pe, onPaneMouseMove: Oe, onPaneMouseLeave: Ie, onPaneScroll: ke, onPaneContextMenu: De, children: Ae, onEdgeUpdate: Be, onEdgeContextMenu: $e, onEdgeDoubleClick: ze, onEdgeMouseEnter: _e, onEdgeMouseMove: Le, onEdgeMouseLeave: Re, onEdgeUpdateStart: He, onEdgeUpdateEnd: Te, edgeUpdaterRadius: Ye = 10, onNodesChange: Xe, onEdgesChange: Ve, noDragClassName: Ze = "nodrag", noWheelClassName: Ke = "nowheel", noPanClassName: Ue = "nopan", fitView: Fe = !1, fitViewOptions: We, connectOnClick: Ge = !0, attributionPosition: je, proOptions: qe, defaultEdgeOptions: Qe, elevateNodesOnSelect: Je = !0, elevateEdgesOnSelect: et = !1, disableKeyboardA11y: tt = !1, autoPanOnConnect: nt = !0, autoPanOnNodeDrag: ot = !0, connectionRadius: rt = 20, isValidConnection: at, onError: it, style: st, id: dt, ...lt }, ct) => { const ut = ao(s, Gt), ht = ao(d, Dt), pt = dt || "1"; return e("div", { ...lt, style: { ...st, ...go }, ref: ct, className: g(["react-flow", i]), "data-testid": "rf__wrapper", id: dt, children: t(ro, { children: [e(eo, { onInit: u, onMove: h, onMoveStart: p, onMoveEnd: m, onNodeClick: l, onEdgeClick: c, onNodeMouseEnter: v, onNodeMouseMove: E, onNodeMouseLeave: C, onNodeContextMenu: N, onNodeDoubleClick: w, nodeTypes: ut, edgeTypes: ht, connectionLineType: T, connectionLineStyle: Y, connectionLineComponent: X, connectionLineContainerStyle: V, selectionKeyCode: K, selectionOnDrag: U, selectionMode: F, deleteKeyCode: Z, multiSelectionKeyCode: G, panActivationKeyCode: W, zoomActivationKeyCode: j, onlyRenderVisibleElements: J, selectNodesOnDrag: ee, defaultViewport: ge, translateExtent: me, minZoom: he, maxZoom: pe, preventScrolling: ye, zoomOnScroll: be, zoomOnPinch: xe, zoomOnDoubleClick: Ne, panOnScroll: ve, panOnScrollSpeed: Ee, panOnScrollMode: Ce, panOnDrag: we, onPaneClick: Me, onPaneMouseEnter: Pe, onPaneMouseMove: Oe, onPaneMouseLeave: Ie, onPaneScroll: ke, onPaneContextMenu: De, onSelectionContextMenu: _, onSelectionStart: L, onSelectionEnd: R, onEdgeUpdate: Be, onEdgeContextMenu: $e, onEdgeDoubleClick: ze, onEdgeMouseEnter: _e, onEdgeMouseMove: Le, onEdgeMouseLeave: Re, onEdgeUpdateStart: He, onEdgeUpdateEnd: Te, edgeUpdaterRadius: Ye, defaultMarkerColor: Se, noDragClassName: Ze, noWheelClassName: Ke, noPanClassName: Ue, elevateEdgesOnSelect: et, rfId: pt, disableKeyboardA11y: tt, nodeOrigin: de, nodeExtent: fe }), e(yt, { nodes: n, edges: o, defaultNodes: r, defaultEdges: a, onConnect: y, onConnectStart: f, onConnectEnd: S, onClickConnectStart: b, onClickConnectEnd: x, nodesDraggable: te, nodesConnectable: ie, nodesFocusable: se, edgesFocusable: le, edgesUpdatable: ce, elementsSelectable: ue, elevateNodesOnSelect: Je, minZoom: he, maxZoom: pe, nodeExtent: fe, onNodesChange: Xe, onEdgesChange: Ve, snapToGrid: q, snapGrid: Q, connectionMode: H, translateExtent: me, connectOnClick: Ge, defaultEdgeOptions: Qe, fitView: Fe, fitViewOptions: We, onNodesDelete: I, onEdgesDelete: D, onNodeDragStart: M, onNodeDrag: P, onNodeDragStop: O, onSelectionDrag: $, onSelectionDragStart: B, onSelectionDragStop: z, noPanClassName: Ue, nodeOrigin: de, rfId: pt, autoPanOnConnect: nt, autoPanOnNodeDrag: ot, onError: it, connectionRadius: rt, isValidConnection: at }), e(gt, { onSelectionChange: A }), Ae, e(k, { proOptions: qe, position: je }), e(Nt, { rfId: pt, disableKeyboardA11y: tt })] }) }) })); ho.displayName = "ReactFlow"; const po = e => e.domNode?.querySelector(".react-flow__edgelabel-renderer"); function mo({ children: e }) { const t = M(po); return t ? v(e, t) : null } function yo() { const e = P(); return u((t => { const { domNode: n, updateNodeDimensions: o } = e.getState(), r = (Array.isArray(t) ? t : [t]).reduce(((e, t) => { const o = n?.querySelector(`.react-flow__node[data-id="${t}"]`); return o && e.push({ id: t, nodeElement: o, forceUpdate: !0 }), e }), []); requestAnimationFrame((() => o(r))) }), []) } const fo = e => e.getNodes(); function So() { return M(fo, m) } const bo = e => e.edges; function xo() { return M(bo, m) } const vo = e => ({ x: e.transform[0], y: e.transform[1], zoom: e.transform[2] }); function Eo() { return M(vo, m) } function Co(e) { return t => { const [n, o] = c(t), r = u((t => o((n => e(t, n)))), []); return [n, o, r] } } const No = Co(Cn), wo = Co(Nn); function Mo({ onStart: e, onChange: t, onEnd: n }) { const o = P(); s((() => { o.setState({ onViewportChangeStart: e }) }), [e]), s((() => { o.setState({ onViewportChange: t }) }), [t]), s((() => { o.setState({ onViewportChangeEnd: n }) }), [n]) } function Po({ onChange: e }) { const t = P(); s((() => { t.setState({ onSelectionChange: e }) }), [e]) } const Oo = { includeHiddenNodes: !1 }; function Io(e = Oo) { const t = M((e => t => 0 !== t.nodeInternals.size && t.getNodes().filter((t => !!e.includeHiddenNodes || !t.hidden)).every((e => void 0 !== e[U]?.handleBounds)))(e)); return t } export { q as BaseEdge, Ee as BezierEdge, ae as ConnectionLineType, ne as ConnectionMode, mo as EdgeLabelRenderer, D as EdgeText, Je as Handle, ie as MarkerType, oe as PanOnScrollMode, I as Panel, se as Position, ho as ReactFlow, oo as ReactFlowProvider, re as SelectionMode, ce as SimpleBezierEdge, me as SmoothStepEdge, ye as StepEdge, Se as StraightEdge, Ae as addEdge, Nn as applyEdgeChanges, Cn as applyNodeChanges, T as boxToRect, B as clamp, ve as getBezierPath, X as getBoundsOfRects, He as getConnectedEdges, Ie as getIncomers, Q as getMarkerEnd, _e as getNodePositionWithOrigin, Oe as getOutgoers, Le as getRectOfNodes, le as getSimpleBezierPath, pe as getSmoothStepPath, fe as getStraightPath, Te as getTransformForBounds, U as internalsSymbol, Me as isEdge, Pe as isNode, H as rectToBox, Be as updateEdge, xo as useEdges, wo as useEdgesState, Vt as useGetPointerPosition, qt as useKeyPress, we as useNodeId, So as useNodes, Io as useNodesInitialized, No as useNodesState, Po as useOnSelectionChange, Mo as useOnViewportChange, gn as useReactFlow, M as useStore, P as useStoreApi, yo as useUpdateNodeInternals, Eo as useViewport }; export default null;
//# sourceMappingURL=/sm/922294e7ad7e314946479ec2e3e26e16df130595051bd7de1c3cce774c94de12.map
